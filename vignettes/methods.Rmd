---
title: "methods"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{methods}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(stgeomx)

library(tidyverse)
library(readxl)
library(writexl)
library(limma)
library(factoextra)
library(umap)
library(fgsea)
library(msigdbr)

library(patchwork)
library(ggrepel)
library(ggridges)
library(pheatmap)
library(sctransform)


```

## Input files and parameter settings

```{r input files, include=FALSE}

# master directory
working_dir <- "/Users/mkiyer/Library/CloudStorage/OneDrive-DukeUniversity/research/projects/st_methods"
dataset_dir <- file.path(working_dir, "datasets")
ref_dir <- file.path(working_dir, "ref")

# dataset paths
gse190088_kidney_sample_tsv <- file.path(dataset_dir, "gse190088_kidney", "GSE190088_Kidney_Sample_Annotations.txt")
gse190088_kidney_counts_tsv <- file.path(dataset_dir, "gse190088_kidney", "GSE190088_Kidney_Raw_BioProbeCountMatrix.txt")
soa_panc_xlsx <- file.path(dataset_dir, "spatial_organ_atlas", "spatial_organ_atlas_pancreas.xlsx")
soa_colon_xlsx <- file.path(dataset_dir, "spatial_organ_atlas", "spatial_organ_atlas_colon.xlsx")

# qc parameters
geomx_negprobe_lod_quantile = 0.9
geomx_min_counts = 50000
geomx_min_auc = 0.65
geomx_aoi_min_frac_expr = 0.2
geomx_gene_min_frac_expr = 0.1

# normalization
norm_method = "qn"
bgcorrect_method = "bgsub"
bgcorrect_bw_adjust = 2
bgcorrect_bg_quant = 0.5

# de parameters
de_padj_cutoff <- 0.05
de_log2fc_cutoff <- 1

# gsea params
gsea_padj_cutoff <- 0.05
gsea_log2fc_cutoff <- 1

plot_dir <- file.path(working_dir, "plots")
if (!dir.exists(plot_dir)) {
  dir.create(plot_dir)
}

```

# Functions

```{r functions}

most_cv_genes <- function(x, ntop=500) {
  rv <- apply(x, 1, function(x) sd(x) / mean(x))
  keep <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  return(x[keep,])
}

run_pca <- function(x) {
  pca <- prcomp(t(x))
  pct_var <- round(100 * pca$sdev^2 / sum( pca$sdev^2 ), 2)
  pct_var <- paste(colnames(pca$x), " (", paste(as.character(pct_var), "%", ")", sep=""), sep="")
  return(list(pca = pca, pct_var = pct_var))
}

pca_plot <- function(pca_res, pca_tbl, color_by, shape_by) {
  p <- ggplot(pca_tbl, aes(x=PC1, y=PC2, color={{color_by}}, shape={{shape_by}})) +
    geom_point(alpha = 0.8, size=2) +
    theme_bw() +
    labs(x=pca_res$pct_var[1], y=pca_res$pct_var[2])
  return(p)
}

pca_bg_fit <- function(x, response, npcs=5) {
  # pca
  pca_res <- prcomp(t(x), center=TRUE, scale=TRUE)
  pct_var <- pca_res$sdev^2 / sum(pca_res$sdev^2)
  tot_rsq <- 0
  for (i in 1:npcs) {
    tbl <- bind_cols(y = response, x = pca_res$x[,i])
    model <- lm(y ~ x, data=tbl)
    msum <- summary(model)
    rsq <- msum$r.squared * pct_var[i]
    tot_rsq <- tot_rsq + rsq
  }
  return(tot_rsq)
}


```

# Read data

```{r read datasets}

ds <- st_geomx_read_tsv(gse190088_kidney_sample_tsv,
                        gse190088_kidney_counts_tsv)
ds <- st_geomx_preprocess(ds, geomx_negprobe_lod_quantile)
ds <- st_geomx_merge_probes(ds)
ds <- st_geomx_rm_empty_aois(ds)

```


```{r qnorm method}

a <- c(1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512)
b <- c(1, 1, 1, 1, 1, 2, 4, 8, 16, 32, 64)
c <- c(1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5)
d <- c(1, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1)
e <- c(1, 64, 32, 16, 8, 4, 2, 1, 1, 1, 1)
f <- c(1, 64, 1, 1, 2, 1, 4, 1, 1, 1, 8)

weights <- c(1, 1, 1, 1, 1, 1)
g <- paste0("g", 1:11)
x <- bind_cols(a=a, b=b, c=c, d=d, e=e, f=f)
rownames(x) <- g


# compute weighted quantiles
xcpm <- apply(x-1, 2, function(x) { 1e6 * x / sum(x) })
xquantiles <- apply(xcpm, 2, sort)

maxdist <- 2 * 1e6 * (nrow(x) - 1)/nrow(x)

xsimilarity <- as.matrix(stats::dist(t(xquantiles), method="manhattan"))
xsimilarity <- 1 - (xsimilarity / maxdist)

n <- 20000
d <- 1e6
maxdist <- rep(0, n)
for (i in 1:n) {
  a <- rep(d / i, i)
  b <- rep(0, i)
  b[i] <- d
  maxdist[i] <- sum(abs(log2(a+1) - log2(b+1))) / i
}

((n-1)*log2(d/n) + log2(n))/n

plot(maxdist)
log2(1e6)/2


a <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
b <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 10)
sum(abs(log(a+1) - log(b+1)))


xrank <- matrix(nrow=nrow(x), ncol=ncol(x))

for(i in 1:ncol(x)) {

}




apply(xquantiles+1, 1, weighted_geomean, weights)-1

xquantiles <- apply(xquantiles, 1, weighted_geomean, weights)

apply(xsort, 1, geomean)


apply(xquantiles+1, 1, geomean)-1

xquantiles <- apply(xquantiles, 1, weighted_geomean, weights)
# renormalize quantiles such that columns sum to one million (e.g. cpm)
xquantiles <- 1e6 * (xquantiles / sum(xquantiles))




final_tiebreak <- "random"
weights <- c(0.8, 0.6, 0.2, 0.1, 0, 0)
alpha <- 1
(quality_weights^10)/sum(quality_weights^10)
tbqnorm(x, weights=weights, alpha=alpha)


x <- ds$counts
weights <- ds$samples$bg_ks_dist
alpha <- 1

weights <- weights ^ alpha

# convert to relative counts (counts-per-million)
xcpm <- apply(x-1, 2, function(x) { 1e6 * x / sum(x) })
xquantiles <- apply(xcpm, 2, sort)

# use correlation to compute sample-sample similarity matrix
xcor <- cor(xcpm, method="spearman")
# exclude samples with negative correlation
xcor[xcor < 0] <- NA
# ordered list of nearest neighbors for each sample
nn_list <- apply(xcor, 2, order, na.last=NA, decreasing=TRUE)


maxdist <- 2 * (nrow(x) - 1)/nrow(x)

xsimilarity <- as.matrix(stats::dist(t(xquantiles), method="manhattan"))
xsimilarity <- 1 - (xsimilarity / (maxdist * 1e6))

xsimilarity[1,1:10]



hist(xsimilarity^0.5)


summary(xsimilarity)

nrow(xquantiles)
colnames(as.matrix(xdist))
hist(xdist)
str(xdist)
summary(xdist)


str(ks.test(x[,1], unlist(x[,2])))
ks.test(x[,1], unlist(x[,2]))$statistic

apply(x, 2, function(y) { ks.test(y, unlist(x[,1]))$statistic })


# starting ranks (with ties present)
#xrank_init <- as.data.frame(apply(x, 2, rank, ties.method="min"))
xrank_init <- reframe(x, across(everything(), min_rank))

# reordering procedure to break ties for each sample
xrank <- matrix(nrow=nrow(x), ncol=ncol(x))
for(i in 1:ncol(x)) {
  # if unable to break ties using nearest neighbors will defer to
  # either global ranks or random ranks
  if (final_tiebreak == "global") {
    tiebrk_ranks <- global_ranks
  } else {
    tiebrk_ranks <- rank(xrank_init[,i], ties.method="random")
  }
  nn_ordered_cols <- bind_cols(xrank_init[, nn_list[[i]]], tiebrk_ranks=tiebrk_ranks)
  xrank[,i] <- do.call(order, unname(nn_ordered_cols))
}
# convert ordering to ranks
xrank <- apply(xrank, 2, order)

# compute weighted quantiles
xquantiles <- apply(xcpm, 2, sort)
xquantiles <- apply(xquantiles, 1, weighted_geomean, weights)
# renormalize quantiles such that columns sum to one million (e.g. cpm)
xquantiles <- 1e6 * (xquantiles / sum(xquantiles))


# apply quantile normalization procedure using new ranks
xnorm <- apply(xrank, 2, function(x) { xquantiles[x] })

xnorm

xnorm

plot(density(x[,2]))

m <- matrix(nrow=4, ncol=5)
m[,1] <- c(0, 0, 0, 10)
m[,2] <- c(1, 2, 3, 4)
m[,3] <- c(0, 0, 1, 9)
m[,4] <- c(6, 2, 1, 1)
m[,5] <- c(5, 3, 1, 1)
m <- as.matrix(dist(t(m)))




normalize_quantile <- function(x) {
  # use row sums as a tiebreaker for genes with equal counts
  row_rank <- rank(rowSums(x), ties.method="random")
  row_ord <- apply(x, 2, order, row_rank)
  # rank matrix with ties broken by row sums
  xrank <- apply(row_ord, 2, order)

  # now standard quantile norm (geomean)
  xsort <- apply(x, 2, sort)
  xgeomean <- apply(xsort, 1, geomean)

  index_to_value <- function(my_index, my_value){
    return(my_value[my_index])
  }

  xnorm <- apply(xrank, 2, index_to_value, xgeomean)
  return(xnorm)
}


quantile_normalization <- function(df){
  df_rank <- apply(df,2,rank,ties.method="average")
  df_sorted <- data.frame(apply(df, 2, sort))
  df_mean <- apply(df_sorted, 1, mean)
   
  index_to_mean <- function(my_index, my_mean){
    return(my_mean[my_index])
  }
   
  df_final <- apply(df_rank, 2, index_to_mean, my_mean=df_mean)
  rownames(df_final) <- rownames(df)
  return(df_final)
}

preprocessCore::normalize.quantiles(as.matrix(x))
quantile_normalization(x)
normalize_quantile(x)
#        [,1] [,2]  [,3] [,4]
#  [1,]   1.0    2 288.0  288
#  [2,]   1.5    2 144.0  144
#  [3,]   2.5    2  72.0   72
#  [4,]   4.5    2  36.0   36
#  [5,]   9.0    9  18.0   18
#  [6,]  18.0   18   9.0    9
#  [7,]  36.0   36   4.5    2
#  [8,]  72.0   72   2.5    2
#  [9,] 144.0  144   1.5    2
# [10,] 288.0  288   1.0    2


```

# GSE190088 kidney data set

```{r kidney wta data, include=FALSE}

ds <- st_geomx_read_tsv(gse190088_kidney_sample_tsv,
                        gse190088_kidney_counts_tsv)
#ds <- st_geomx_read_xlsx(soa_colon_xlsx)
ds <- st_geomx_preprocess(ds, geomx_negprobe_lod_quantile)
ds <- st_geomx_merge_probes(ds)
ds <- st_geomx_rm_empty_aois(ds)

hist(ds$samples$bg_ks_dist)

# s <- mutate(ds$samples, 
#   region_segment = case_when(region == "tubule" & segment == "panck" ~ "distal_tubule",
#                              region == "tubule" & segment == "neg" ~ "proximal_tubule",
#                              region == "glomerulus" ~ "glomerulus")
# )
# s$region_segment <- factor(s$region_segment)


sort(ds$samples$bg_auc, d=TRUE)[1:10]
x <- log2(unlist(ds$counts[, "s02_r008_geometricsegment"]))
bg <- ds$meta$bg

sd(x[bg])
mean(x[bg])
bgcorrect_bw_adjust
bw <- max(bw.nrd0(x[bg]), bw.nrd0(x[!bg])) * bgcorrect_bw_adjust

mu <- mean(x[bg])
s2 <- sd(x[bg])^2
al <- 1
f <- x

myll <- NULL
a <- seq(0, 10, length.out=1001)
for (i in 1:length(a)) {
  al <- a[i]
  myll[i] <- .C("normexp_m2loglik",
     mu = as.double(mu), 
     s2 = as.double(s2), 
     al = as.double(al), 
     n = as.integer(length(f)), 
     f = as.double(f), 
     m2LL = double(1),
     PACKAGE="limma"
  )$m2LL
}

plot(myll)
myll





normcounts = list()
bgcorrect_methods <- c("none", "qq", "bgsub", "kdeppv", "kdefor")
norm_methods <- c("cpm", "qn", "rle", "q3", "tmm")
pca_bg_fits <- NULL
de <- NULL
width <- 16
height <- 10




x <- log2(ds$counts)

tbl <- bind_cols(
  m = rowMeans(x),
  v = apply(x, 1, function(x) var(x)),
  cv2 = apply(x, 1, function(x) { (sd(x)/mean(x))^2 }),
)

#plot(glm(v ~ m, family=gaussian(link="identity"), data=tbl))

lovar <- loess(v ~ m, data=tbl, span=0.75)
tbl$lovar <- predict(lovar)

ggplot(tbl) +
  geom_point(aes(m, v), alpha=0.5) +
  geom_line(aes(m, lovar), color="magenta")




x <- st_geomx_bgcorrect(ds, method="kdefor", 
                        bw.adjust=bgcorrect_bw_adjust, 
                        bg.quant=bgcorrect_bg_quant)



x <- st_geomx_bgcorrect(ds, method="kdefor", 
                        bw.adjust=bgcorrect_bw_adjust, 
                        bg.quant=bgcorrect_bg_quant)

summary(apply(x, 2, function(x) { length(unique(x)) }))
summary(apply(x, 2, function(x) { max(x) }))

summary(rowMeans(x))


m <- as.matrix(x)
rownames(m) <- ds$meta$gene
vst_out <- sctransform::vst(m-1)
y <- vst_out$y


x <- st_geomx_normalize(ds, x, method="qn")
y <- log2(x)

# dec <- scran::modelGeneVar(y)
# plot(dec$mean, dec$total, xlab="Mean log-expression", ylab="Variance")
# curve(dec@metadata$trend(x), col="blue", add=TRUE)

tbl <- bind_cols(
  m = rowMeans(x),
  v = apply(y, 1, function(x) var(x)),
  cv2 = apply(y, 1, function(x) { (sd(x)/mean(x))^2 }),
)

MASS::glm(v ~ m, data=tbl)


plot(glm(v ~ m, family=gaussian(link="identity"), data=tbl))


lovar <- loess(v ~ m, data=tbl, span=0.75)
tbl$lovar <- predict(lovar)

ggplot(tbl) +
  geom_point(aes(m, v), alpha=0.5) +
  geom_line(aes(m, lovar), color="magenta")


# kmeans
clust <- stats::kmeans(t(y), centers=3, nstart=5)
s$community3 <- factor(clust$cluster)

# hclust
clust <- hclust(dist(t(y), method="euclidean"), method="ward.D2")
s$community3 <- factor(cutree(p, k=3))
s$community4 <- factor(cutree(p, k=4))
s$community5 <- factor(cutree(p, k=5))

# clustering/community detection
g <- scran::buildSNNGraph(y, d=10, k=0.1*nrow(s))
clust <- igraph::cluster_leiden(g,
                                objective_function="modularity",
                                resolution=0.5,
                                n_iterations=1000)
igraph::modularity(g, igraph::membership(clust))
table(igraph::membership(clust))
#igraph::V(g)$community <- factor(clust$membership)

s$community <- factor(clust$membership)



## PCA analysis
pca_res <- run_pca(y)
pca_tbl <- bind_cols(s, as_tibble(pca_res$pca$x))

# plots
p1 <- pca_plot(pca_res, pca_tbl, bg_auc, disease_status) +
  scale_color_viridis_c()
p2 <- pca_plot(pca_res, pca_tbl, log10(complexity), disease_status) +
  scale_color_viridis_c()
p3 <- pca_plot(pca_res, pca_tbl, region_segment, disease_status) +
  scale_color_manual(values = pals::cols25())
p4 <- pca_plot(pca_res, pca_tbl, SlideName, disease_status) +
  scale_color_manual(values = pals::cols25())
p5 <- pca_plot(pca_res, pca_tbl, community3, disease_status) +
  scale_color_manual(values = pals::cols25())


p <- (p1 + p3) / (p4 + p5)
p
f <- file.path(plot_dir, paste0("pca_", method, ".pdf"))
ggsave(f, plot=p, device="pdf", width=width, height=height)



as_tibble(igraph::as_data_frame(g, what="vertices"))
clust <- igraph::cluster_leiden(g, 
                                objective_function="modularity",
                                resolution=r,
                                n_iterations = 100)


res <- NULL
i <- 1
for (r in seq(0.01, 1, by=0.01)) {
  clust <- igraph::cluster_leiden(g, 
                                  objective_function="modularity",
                                  resolution=r,
                                  n_iterations = 100)
  res[[i]] <- tibble(m = igraph::modularity(g, igraph::membership(clust)),
                     n = clust$nb_clusters,
                     q = clust$quality,
                     r = r)
  i <- i+ 1
}
res <- bind_rows(res)
p1 <- ggplot(res, aes(x=r, y=m)) + 
  geom_point() + 
  labs(x="resolution", y="modularity")
p2 <- ggplot(res, aes(x=r, y=n)) + 
  geom_point() +
  labs(x="resolution", y="# of clusters")
p1 + p2


```


```{r compare}

for (bgcorrect_method in bgcorrect_methods) {
  for (norm_method in norm_methods) {
    method <- paste0(bgcorrect_method, "_", norm_method)
    print(method)
    x <- st_geomx_bgcorrect(ds, method=bgcorrect_method, 
                            bw.adjust=bgcorrect_bw_adjust, 
                            bg.quant=bgcorrect_bg_quant)
    x <- st_geomx_normalize(ds, x, method=norm_method)
    
    # only most variable genes
    # y <- most_cv_genes(log2(x), 5000)
    y <- log2(x)
    rsq <- pca_bg_fit(y, s$bg_ks_dist, npcs=50)
    pca_bg_fits <- bind_rows(pca_bg_fits,
                             bind_cols(bgcorrect_method=bgcorrect_method, 
                                       norm_method=norm_method,
                                       rsq=rsq))
    ## PCA analysis
    pca_res <- run_pca(y)
    pca_tbl <- bind_cols(s, as_tibble(pca_res$pca$x))

    # plots
    p1 <- pca_plot(pca_res, pca_tbl, bg_auc, disease_status) +
      scale_color_viridis_c()
    p2 <- pca_plot(pca_res, pca_tbl, log10(num_counts), disease_status) +
      scale_color_viridis_c()
    p3 <- pca_plot(pca_res, pca_tbl, region_segment, disease_status) +
      scale_color_manual(values = pals::cols25())
    p4 <- pca_plot(pca_res, pca_tbl, SlideName, disease_status) +
      scale_color_manual(values = pals::cols25())
    p <- (p1 + p2) / (p3 + p4)
    f <- file.path(plot_dir, paste0("pca_", method, ".pdf"))
    ggsave(f, plot=p, device="pdf", width=width, height=height)

    # # region
    # p2 <- pca_plot(pca_res, pca_tbl, region_segment, disease_status) +
    #   scale_color_manual(values = pals::cols25())
    # f <- file.path(plot_dir, paste0("pca_", method, "_region.pdf"))
    # ggsave(f, plot=p1, device="pdf")
    # 
    # # slide
    # p3 <- pca_plot(pca_res, pca_tbl, SlideName, disease_status) +
    #   scale_color_manual(values = pals::cols25())
    # f <- file.path(plot_dir, paste0("pca_", method, "_slide.pdf"))
    # ggsave(f, plot=p1, device="pdf")


    ## DE analysis
    # y <- log2(x[,s$aoi])
    # res <- run_limma_trend(y, design, contrasts, 
    #                        padj_cutoff=de_padj_cutoff, 
    #                        log2fc_cutoff=de_log2fc_cutoff)
    # res <- res %>% mutate(
    #   bgcorrect_method = bgcorrect_method,
    #   norm_method = norm_method
    # )
    # de <- bind_rows(de, res)
  }
}


arrange(pca_bg_fits, rsq)


de <- de %>% mutate(
  analysis = paste0(contrast, "_", bgcorrect_method, "_", norm_method)
)


# gsea
de_inv <- filter(de, contrast == "inv_vs_nl")
gsea <- NULL
fgsea_nperm <- 10000


ranks <- get_de_ranks(de_inv, "inv_vs_nl_none_cpm", "lfc")
res <- fgseaSimple(pathways=gs_pdac,
             stats=ranks,
             nperm=100000,
             nproc=1)

range(ranks)
summary(ranks)
sum(is.na(ranks))
length(unique(names(ranks)))
#                 nproc=1)


    ranks <- get_de_ranks(de, a, rank_method)
#     res <- fgseaSimple(pathways=gs,
#                        stats=ranks,
#                        nperm=fgsea.nperm)
# #                       nproc=1)
    res <- fgsea(pathways=gs,
                 stats=ranks,
                 eps=0,
                 nPermSimple=fgsea.nperm)
#                 nproc=1)

for (rank_method in c("lfc", "p", "lfcp", "q")) {
  print(rank_method)
  res <- run_batch_fgsea(gs_pdac, de_inv, unique(de_inv$analysis), 
                         rank_method=rank_method, 
                         fgsea.nperm=fgsea_nperm)
  res$rank_method <- rank_method
  gsea <- bind_rows(gsea, res)
}

gsea <- gsea %>% 
  rowwise() %>% 
  mutate(num_leading_edge = length(leadingEdge)) %>% 
  ungroup()

gsea_pdac <- as_tibble(gsea)

# write comparison data
write_xlsx(list(de = de, 
                gsea_pdac = gsea_pdac,
                pca_bg_fits = pca_bg_fits),
           file.path(working_dir, "bg_correct_cmp_results.xlsx"))
# write gsea results
f <- file.path(working_dir, paste0("gsea_pdac_results.tsv"))
data.table::fwrite(gsea_pdac, file=f, sep="\t", sep2=c("", " ", ""))




p <- plot_gsea_barplot(gsea) +
  facet_grid(rank_method ~ analysis)

ggsave(file.path(plot_dir, "gsea_bg_cmp_pdac.pdf"), p, width=30, height=20)

?ggsave
plot_gsea_volcano(gsea_pdac)

# PDAC GSEA Analysis
prefix <- "gsea_pdac"
padj_cutoff <- 0.05
run_batch_fgsea(analyses)
gsea <- run_batch_fgsea(analyses, de, gs_pdac)






```








```

# Spatial Organ Atlas: Colon

```{r geomx data, include=FALSE}

ds <- st_geomx_read_xlsx(soa_colon_xlsx)
ds <- st_geomx_process_input(ds, geomx_negprobe_lod_quantile)
ds <- st_geomx_merge_probes(ds)
ds <- st_geomx_rm_empty_aois(ds)



table(ds$samples$slide)
table(ds$samples$segment)
table(ds$samples$Group, ds$samples$segment)


```

## QC and filtering AOI / Genes

```{r choose filtering thresholds}

summary(ds$samples$num_counts)
summary(ds$samples$frac_expr)

ds <- st_geomx_set_thresholds(ds, 
                              min_counts = geomx_min_counts,
                              min_auc = geomx_min_auc,
                              aoi_min_frac_expr = geomx_aoi_min_frac_expr,
                              gene_min_frac_expr = geomx_gene_min_frac_expr)

# filter AOIs
p <- st_geomx_plot_aoi_filter(ds, geomx_min_counts, geomx_min_auc, geomx_aoi_min_frac_expr)
p
ggsave(file.path(plot_dir, "qc_aoi_filter.pdf"), p)

ggplot(ds$samples, aes(num_counts, bg_auc, color=region)) +
geom_point() +
scale_x_log10()

# filter genes
p <- st_geomx_plot_gene_filter(ds, geomx_gene_min_frac_expr)
p
ggsave(file.path(plot_dir, "qc_gene_filtering_fpr_auc.pdf"), p)

# apply filters
fds <- list(samples = ds$samples,
            meta = ds$meta,
            counts = ds$counts)
fds <- st_geomx_filter(fds)


nrow(ds$samples)
nrow(fds$samples)
table(ds$meta$keep)
table(ds$samples$slide)
table(ds$samples$segment)

table(ds$samples$Group, ds$samples$segment)
table(fds$samples$Group, fds$samples$segment)
table(ds$samples$Group, ds$samples$keep)


```

# Read MSigDB / GSEA data

```{r msigdb data}

# read msigdb data
msigdb_gene_sets = msigdbr(species = "Homo sapiens")
msigdb_gene_sets <- msigdb_gene_sets %>% 
  filter(gene_symbol %in% fds$meta$gene) %>%
  distinct(gs_name, gene_symbol, .keep_all = TRUE)

# discovery analysis across msigdb gene sets
gs_hallmark <- filter(msigdb_gene_sets, gs_cat == "H")
gs_hallmark <- split(x = gs_hallmark$gene_symbol, f = gs_hallmark$gs_name)
gs_gobp <- filter(msigdb_gene_sets, gs_cat == "C5", gs_subcat == "GO:BP")
gs_gobp <- split(x = gs_gobp$gene_symbol, f = gs_gobp$gs_name)

```



## Normalization

```{r analysis}

most_cv_genes <- function(x, ntop=500) {
  rv <- apply(x, 1, function(x) sd(x) / mean(x))
  keep <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  return(x[keep,])
}

run_pca <- function(x) {
  pca <- prcomp(t(x))
  pct_var <- round(100 * pca$sdev^2 / sum( pca$sdev^2 ), 2)
  pct_var <- paste(colnames(pca$x), " (", paste(as.character(pct_var), "%", ")", sep=""), sep="")
  return(list(pca = pca, pct_var = pct_var))
}

pca_plot <- function(pca_res, pca_tbl, color_by, shape_by) {
  p <- ggplot(pca_tbl, aes(x=PC1, y=PC2, color={{color_by}}, shape={{shape_by}})) +
    geom_point(alpha = 0.8, size=2) +
    theme_bw() +
    labs(x=pca_res$pct_var[1], y=pca_res$pct_var[2])
  return(p)
}

pca_bg_fit <- function(x, response, npcs=5) {
  # pca
  pca_res <- prcomp(t(x), center=TRUE, scale=TRUE)
  pct_var <- pca_res$sdev^2 / sum(pca_res$sdev^2)
  tot_rsq <- 0
  for (i in 1:npcs) {
    tbl <- bind_cols(y = response, x = pca_res$x[,i])
    model <- lm(y ~ x, data=tbl)
    msum <- summary(model)
    rsq <- msum$r.squared * pct_var[i]
    tot_rsq <- tot_rsq + rsq
  }
  return(tot_rsq)
}

# normalization
bgcorrect_method <- "bgsub"
norm_method <- "qn"
method <- paste0(bgcorrect_method, "_", norm_method)
x <- st_geomx_bgcorrect(fds, method=bgcorrect_method, 
                        bw.adjust=bgcorrect_bw_adjust, 
                        bg.quant=bgcorrect_bg_quant)
x <- st_geomx_normalize(fds, x, method=norm_method)

## PCA analysis
y <- log2(x)
pca_res <- run_pca(y)
pca_tbl <- bind_cols(fds$samples, as_tibble(pca_res$pca$x))

width <- 5
height <- 4

# bg_ks_dist
p1 <- pca_plot(pca_res, pca_tbl, bg_ks_dist, path_specimen) +
  scale_color_viridis_c()
f <- file.path(plot_dir, paste0("pca_", method, "_bg_ks_dist.pdf"))
ggsave(f, plot=p1, device="pdf", width=width, height=height)

# patient
p1 <- pca_plot(pca_res, pca_tbl, patient, path_specimen) +
  scale_color_manual(values = pals::cols25())
f <- file.path(plot_dir, paste0("pca_", method, "_patient.pdf"))
ggsave(f, plot=p1, device="pdf", width=width, height=height)

# path
p1 <- pca_plot(pca_res, pca_tbl, path_specimen, path_specimen) +
  scale_color_manual(values = pals::cols25())
f <- file.path(plot_dir, paste0("pca_", method, "_path_specimen.pdf"))
ggsave(f, plot=p1, device="pdf", width=width, height=height)

p1 <- pca_plot(pca_res, pca_tbl, path_aoi, path_specimen) +
  scale_color_manual(values = pals::cols25())
f <- file.path(plot_dir, paste0("pca_", method, "_path_aoi.pdf"))
ggsave(f, plot=p1, device="pdf", width=width, height=height)


# DE analysis comparing LGD lesions
s <- fds$samples
s$patient <- factor(s$patient)
s$path_aoi <- factor(s$path_aoi, levels=c("nl", "lgd", "hgd", "inv"))
s$path_specimen <- factor(s$path_specimen, levels=c("lgd", "inv"))
s$path_patient <- paste0(s$path_specimen, "_", s$path_aoi)
s$path_patient <- factor(s$path_patient, levels=c("lgd_nl", "lgd_lgd", "inv_nl", "inv_lgd", "inv_hgd", "inv_inv"))
levels(s$path_patient)
table(s$path_patient)

design <- model.matrix(~0 + path_patient, s)
colnames(design) <- levels(s$path_patient)
colnames(design)
contrasts <- makeContrasts(invlgd_vs_lgdlgd = inv_lgd - lgd_lgd,
                           invnl_vs_lgdnl = inv_nl - lgd_nl,
                           levels=design)

y <- log2(x[,s$aoi])
res <- run_limma_trend(y, design, contrasts, 
                       padj_cutoff=de_padj_cutoff, 
                       log2fc_cutoff=de_log2fc_cutoff)
res <- res %>% mutate(
  bgcorrect_method = bgcorrect_method,
  norm_method = norm_method
)
de <- res

table(filter(res, contrast == "invlgd_vs_lgdlgd")$de)
table(filter(res, contrast == "invnl_vs_lgdnl")$de)
table(res$de)

x <- filter(res, contrast == "invlgd_vs_lgdlgd")
table(x$de)
p <- plot_de_volcano(x)
ggsave(file.path(plot_dir, "de_invlgd_vs_lgdlgd.pdf"), p, width=8, height=8)



# DE analysis of INV lesions
s <- filter(fds$samples, path_specimen == "inv")
s$patient <- factor(s$patient)
s$path_aoi <- factor(s$path_aoi, levels=c("nl", "lgd", "hgd", "inv"))
design <- model.matrix(~0 + path_aoi + patient, s)
contrasts <- makeContrasts(inv_vs_nl = path_aoiinv - path_aoinl,
                           hgd_vs_nl = path_aoihgd - path_aoinl,
                           lgd_vs_nl = path_aoilgd - path_aoinl,
                           levels=design)

## DE analysis
y <- log2(x[,s$aoi])
res <- run_limma_trend(y, design, contrasts, 
                       padj_cutoff=de_padj_cutoff, 
                       log2fc_cutoff=de_log2fc_cutoff)
res <- res %>% mutate(
  bgcorrect_method = bgcorrect_method,
  norm_method = norm_method
)
de <- bind_rows(de, res)


```


## QC: Background correction

```{r background correction}

# params for plot
quantiles=c(0.10, 0.25, 0.5, 0.75, 0.90, 0.99)
width <- 16
height <- 6

# params for bgcorrect
bw.adjust <- 1
bg.quant <- 0.5


## plots

# raw cpm
x <- as_tibble(cpm(ds$counts))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_none_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_none_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, xraw)
# f <- file.path(plot_dir, "qc_bgcorrect_none_boxplot.pdf")
# ggsave(f, p, width=width, height=8)

# bgsub cpm
x <- st_geomx_bgcorrect(ds, method="bgsub", bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_bgsub_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_bgsub_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_bgsub_boxplot.pdf")
# ggsave(f, p, width=16, height=8)

# qq cpm
x <- st_geomx_bgcorrect(ds, method="qq", bw.adjust=bw.adjust, bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_qq_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_qq_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_qq_boxplot.pdf")
# ggsave(f, p, width=16, height=8)

# ppv cpm
x <- st_geomx_bgcorrect(ds, method="kdeppv", bw.adjust=bw.adjust, bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_ppv_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_ppv_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_ppv_boxplot.pdf")
# ggsave(f, p, width=16, height=8)

# for cpm
x <- st_geomx_bgcorrect(ds, method="kdefor", bw.adjust=bw.adjust, bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_kdefor_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_kdefor_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_kdefor_boxplot.pdf")
# ggsave(f, p, width=16, height=8)


```



## Apply filters and normalize

Consolidate technical replicates. When sample has replicates, choose replicate with greater signal-to-noise ratio

```{r filter and normalize}


# bg correct
#x <- fds$counts

x <- st_geomx_bgcorrect(fds, method=bgcorrect_method, 
                        bw.adjust=bgcorrect_bw_adjust, 
                        bg.quant=bgcorrect_bg_quant)

# normalize
normcounts <- st_geomx_normalize(fds, x, method=norm_method)

```



## QC plot: normalization

```{r qc normalization}

# sample annotations to use in plots
s <- select(fds$samples, aoi, slide, keep, path_aoi, path_specimen)
x <- bind_cols(fds$meta, normcounts)
x <- x %>%
  pivot_longer(s$aoi, names_to="aoi", values_to="count") %>%
  inner_join(s, by=c("aoi"="aoi"), suffix=c("_gene", "_aoi"))

y <- x %>%
  group_by(aoi, expressed) %>%
  summarise(slide = unique(slide),
            med = median(count),
            q3 = quantile(count, 0.75)) %>%
  ungroup()

p <- ggplot(x, aes(x=count, y=reorder(aoi, count), fill=slide)) +
  stat_density_ridges(color="#00000066", alpha=0.4, scale=10, rel_min_height=0.001, quantile_lines=TRUE) +
  scale_x_log10() +
  scale_fill_manual(values = pals::cols25()) +
  xlab("Count") +
  ylab("AOIs") +
  labs(fill = "Slide") +
  theme_ridges() +
  theme(axis.text.y = element_blank()) +
  facet_grid(slide ~ ., scales="free_y")
p
f <- file.path(plot_dir, "qc_ridge_plot_norm_aoi.pdf")
ggsave(f, plot=p, device="pdf", width = 8, height = 8)


# by aoi path
p <- x %>%
  ggplot(aes(x=count, y=factor(path_aoi), fill=factor(path_aoi))) +
  stat_density_ridges(alpha=0.7, scale=3, rel_min_height=0.001, quantile_lines=TRUE) + 
  scale_color_manual(values = pals::cols25()) + 
  scale_x_log10() +
  theme_ridges() + 
  theme(axis.text = element_text(size=5))
p
f <- file.path(plot_dir, "qc_ridge_plot_norm_path.pdf")
ggsave(f, plot=p, device="pdf", width = 8, height = 8)

# by specimen path
p <- x %>%
  ggplot(aes(x=count, y=factor(path_aoi), fill=factor(path_specimen))) +
  stat_density_ridges(alpha=0.7, scale=3, rel_min_height=0.001, quantile_lines=TRUE) + 
  scale_color_manual(values = pals::cols25()) + 
  scale_x_log10() +
  theme_ridges() + 
  theme(axis.text = element_text(size=5))
p
f <- file.path(plot_dir, "qc_ridge_plot_norm_class.pdf")
ggsave(f, plot=p, device="pdf", width = 8, height = 8)


```


## Unsupervised clustering / dimensionality reduction

```{r dim reduction}
library(factoextra)
library(umap)

most_cv_genes <- function(x, ntop=500) {
  rv <- apply(x, 1, function(x) sd(x) / mean(x))
  keep <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  return(x[keep,])
}

run_pca <- function(x) {
  pca <- prcomp(t(x))
  pct_var <- round(100 * pca$sdev^2 / sum( pca$sdev^2 ), 2)
  pct_var <- paste(colnames(pca$x), " (", paste(as.character(pct_var), "%", ")", sep=""), sep="")
  return(list(pca = pca, pct_var = pct_var))
}

y <- log2(normcounts)
y <- most_cv_genes(y, 1000)

pca_res <- run_pca(y)
pca_tbl <- bind_cols(fds$samples, as_tibble(pca_res$pca$x))

# pca plots
p <- ggplot(pca_tbl, aes(x=PC1, y=PC2)) +
  theme_minimal() +
  labs(x=pca_res$pct_var[1], y=pca_res$pct_var[2])

# qc factors
p1 <- p + geom_point(aes(color=bg_auc), alpha = 0.8, size=2) +
  scale_color_viridis_c()
p1
ggsave(file.path(plot_dir, "pca_bg_auc.pdf"), plot=p1, device="pdf")

# segment
p1 <- p + geom_point(aes(color=segment), alpha = 0.8, size=2) +
  scale_color_manual(values = pals::cols25())
p1
ggsave(file.path(plot_dir, "pca_segment.pdf"), plot=p1, device="pdf")

# slide
p1 <- p + geom_point(aes(color=slide), alpha = 0.8, size=2) +
  scale_color_manual(values = pals::cols25())
p1
ggsave(file.path(plot_dir, "pca_path_slide.pdf"), plot=p1, device="pdf")

# path
p1 <- p + geom_point(aes(color=path_aoi, shape=path_specimen), alpha = 0.8, size=2) +
  scale_color_manual(values = pals::cols25())
p1
ggsave(file.path(plot_dir, "pca_path_segment.pdf"), plot=p1, device="pdf")


# investigate contributions to pca
res.pca <- prcomp(y, scale = TRUE)
p <- fviz_pca_ind(res.pca, select.ind=list(contrib=20), repel=TRUE, ggrepel.max.overlaps=Inf)
p
ggsave(file.path(plot_dir, "pca_ind.pdf"), p)

p <- fviz_contrib(res.pca, choice = "ind", axes = 1, top=20, max.overlaps=Inf)
p
ggsave(file.path(plot_dir, "pca_contrib.pdf"), p)


# UMAP variable genes
umap_fit <- t(y) %>%
   scale() %>% 
   umap()
umap_df <- umap_fit$layout %>%
   as.data.frame() %>%
   dplyr::rename(umap1 = "V1",
                 umap2 = "V2")
umap_df <- bind_cols(fds$samples, umap_df)


p <- ggplot(umap_df, aes(x=umap1, y=umap2)) +
  theme_minimal()

p1 <- p + geom_point(aes(color=bg_auc), alpha = 0.8, size=2) +
  scale_color_viridis_c()
p1

# segment
p1 <- p + geom_point(aes(color=segment), alpha = 0.8, size=2) +
  scale_color_manual(values = pals::cols25())
p1

# slide
p1 <- p + geom_point(aes(color=slide), alpha = 0.8, size=2) +
  scale_color_manual(values = pals::cols25())
p1

# segment / path
p1 <- p + geom_point(aes(color=path_aoi, shape=path_specimen), alpha = 0.8, size=2) +
  scale_color_manual(values = pals::cols25())
p1



```

## Clustering high variance genes

```{r}
library(pheatmap)

y <- log2(normcounts)
y <- most_cv_genes(y, 1000)

s <- fds$samples %>% mutate(noise_quantile = ntile(desc(bg_auc), 4))

annot_col <- column_to_rownames(s, "aoi") %>% 
  select(slide = slide,
         path_aoi = path_aoi,
         path_specimen = path_specimen,
         noise_quantile = noise_quantile) %>%
  as.data.frame()

p <- pheatmap(y,
         scale="row",
         show_rownames=FALSE,
         show_colnames=FALSE,
         border_color=NA,
         clustering_method = "average",
         clustering_distance_rows = "correlation",
         clustering_distance_cols = "correlation",
         breaks = seq(-3, 3, 0.05),
         color = colorRampPalette(c("purple3", "black", "yellow2"))(120),
         annotation_col = annot_col)

f <- file.path(plot_dir, "heatmap_cluster_highcv_genes.pdf")
save_pheatmap_pdf(p, filename=f, width=12, height=8)

```

## Differential expression analysis

```{r de analysis setup}

limma_rename_result_cols <- function(res) {
  as_tibble(res, rownames="gene") %>%
    select(gene,
           log2fc=logFC,
           avgexpr=AveExpr,
           pval=P.Value,
           padj=adj.P.Val)
}

de_format_results <- function(res, analysis, method, 
                              padj_cutoff, log2fc_cutoff) {
  mutate(res, 
         de = case_when(padj > padj_cutoff ~ "no",
                        log2fc < -log2fc_cutoff ~ "dn",
                        log2fc > log2fc_cutoff ~ "up",
                        TRUE ~ "no"),
         analysis = analysis,
         method = method)
}

run_limma_trend <- function(y, design, contrasts) {
  fit <- lmFit(y, design)
  fit <- contrasts.fit(fit, contrasts)
  fit <- eBayes(fit, trend=TRUE)
  return(fit)
}

process_limma <- function(fit, contrasts, method, 
                          padj_cutoff, log2fc_cutoff) {
  x <- NULL
  for (coef in colnames(contrasts)) {
    res <- topTable(fit, coef=coef, number=Inf, sort.by="none")
    res <- limma_rename_result_cols(res)
    res <- de_format_results(res, 
                             analysis=coef, 
                             method=method,
                             padj_cutoff=padj_cutoff, 
                             log2fc_cutoff=log2fc_cutoff)
    x <- bind_rows(x, res)
  }
  return(x)
}


plot_de_volcano <- function(res) {
  # res <- res %>% 
  #   mutate(de = case_when(padj > 0.05 ~ "no",
  #                         log2fc < 0 ~ "dn",
  #                         log2fc > 0 ~ "up"))
  p <- ggplot(res, aes(x=log2fc, y=-log10(padj), color=de, size=de)) +
    geom_point(alpha=0.7) +
#    geom_text_repel(data=subset(res, de != "no"), color="black", size=3, aes(label=gene), max.overlaps=Inf) +
    geom_text_repel(data=subset(res, de != "no"), color="black", size=3, aes(label=gene)) +
    scale_color_manual(values=c("no"="grey", "dn"="blue", "up"="red")) +
    scale_size_manual(values=c("no"=1, "dn"=2, "up"=2)) +
    theme_minimal() +
    theme(legend.position="bottom") + 
    theme(axis.line = element_line(color = "black"))
    labs(x="log2fc", y="-log10(padj)")
  return(p)
}


```


## DE analysis: epithelial compartment, specimens with invasive carcinoma

```{r between de analysis pathology}


# de <- NULL
# for (analysis in names(analysis_samples)) {
#   print(analysis)
#   s <- analysis_samples[[analysis]]
#   
#   # design
#   on_icb_response <- s$time == "t1" & s$response == "yes"
#   on_icb_no_response <- s$time == "t1" & s$response == "no"
#   design <- model.matrix(~patient, data=s)
#   design_response <- cbind(design, on_icb_no_response, on_icb_response)
# 
#   y <- log2(g_qn_cpm + log2_prior_count)
#   y <- get_filtered_subset(norm_expr_mat[, s$library], 
#                            min.expr = de_min_log2_cpm, 
#                            min.prop = de_min_prop)
#   print(nrow(y))
#   res <- run_limma_trend(y, design_response, "on_icb_response", 
#                          de_padj_cutoff, de_log2fc_cutoff,
#                          analysis, method)
#   de <- bind_rows(de, res)
# }
# table(de$analysis, de$de)



table(fds$samples$path_aoi, fds$samples$slide)

s <- fds$samples %>% filter(path_specimen == "inv", segment == "panck")
s$path <- factor(tolower(s$path_aoi), levels=c("nl", "lgd", "hgd", "inv"))
y <- log2(normcounts)[,s$aoi]

# de analysis
de <- NULL
method <- "limma_trend"

design <- stats::model.matrix(~0 + slide + path, data=s)
colnames(design)

table(s$slide, s$path)




colnames(design) <- levels(s$path)
s$path
contrasts <- limma::makeContrasts(lgd_vs_nl = panck_lgd - panck_nmld,
                                  hgd_vs_nl = panck_hgd - panck_nmld,
                                  inv_vs_nl = panck_inv - panck_nmld,
                                  hgd_vs_lgd = panck_hgd - panck_lgd,
                                  inv_vs_lgd = panck_inv - panck_lgd,
                                  inv_vs_hgd = panck_inv - panck_hgd,
                                  invhgd_vs_lgdnl = (panck_inv + panck_hgd)/2 - (panck_lgd + panck_nmld)/2,
                                  levels=design)
fit <- run_limma_trend(y, design, contrasts)
res <- process_limma(fit, contrasts, method, de_padj_cutoff, de_log2fc_cutoff) 
de <- bind_rows(de, res)


model.matrix(~slide, data=s)

# 
# # design
# on_icb_response <- s$time == "t1" & s$response == "yes"
# on_icb_no_response <- s$time == "t1" & s$response == "no"
# design <- model.matrix(~patient, data=s)
# design_response <- cbind(design, on_icb_no_response, on_icb_response)
# 
# y <- log2(g_qn_cpm + log2_prior_count)
# y <- get_filtered_subset(norm_expr_mat[, s$library], 
#                          min.expr = de_min_log2_cpm, 
#                          min.prop = de_min_prop)
# print(nrow(y))
# res <- run_limma_trend(y, design_response, "on_icb_response", 
#                        de_padj_cutoff, de_log2fc_cutoff,
#                        analysis, method)
# de <- bind_rows(de, res)

write_xlsx(de, file.path(working_dir, "de_path.xlsx"))


res %>% filter(gene == "LAMB3")
res %>% filter(analysis == "hgd_vs_lgd") %>% arrange(padj)
table(res$analysis, (res$de == "up") & (res$padj < 1e-3))


write_xlsx(de)

plot_de_volcano(res) +
  facet_wrap(~ analysis)
  



```

## plot individual genes

```{r plot genes}

plot_gene <- function(s, x, gene, aes_x, aes_color) {
  exprs <- unlist(x[gene, ])
  x <- s %>% add_column(gene = exprs)
  p <- ggplot(x, aes(x={{ aes_x }}, y=gene, fill={{aes_color}})) +
    geom_boxplot(outlier.shape = NA, width=0.5) +
    geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.5)) +
    scale_fill_manual(values=pals::cols25()) +
    ggtitle(paste0("Gene: ", gene)) +
    theme_minimal() + 
    theme(axis.text.x = element_text(color = "black", angle = 90, vjust = 0.5, hjust=1)) +
    theme(axis.line = element_line(color = "black"))
  return(p)
}


de %>% filter(gene == "PMM1")
p <- plot_gene(s, y, "PMM1", acral, acral)
p

p <- plot_gene(s, y, "PI15", os_quartile, os_quartile)
p
ggsave(file.path(plot_dir, "gene_afap1l2_os.pdf"), p)


plot_gene(s, y, "ATP5MC3", os_quartile, os_quartile)
de %>% filter(padj < 0.05)


```


## bg correction testing

```{r bg correction testing}

# params for plot
quantiles=c(0.10, 0.25, 0.5, 0.75, 0.90, 0.99)
width <- 16
height <- 6
  
# params for bgcorrect
bw.adjust <- 2
bg.quant <- 0.5

bg <- ds$meta$bg
x <- ds$counts


## plots

# raw cpm
x <- as_tibble(cpm(ds$counts))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_none_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_none_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, xraw)
# f <- file.path(plot_dir, "qc_bgcorrect_none_boxplot.pdf")
# ggsave(f, p, width=width, height=8)

# qq cpm
x <- st_geomx_bgcorrect(ds, method="qq", bw.adjust=bw.adjust, bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_qq_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_qq_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_qq_boxplot.pdf")
# ggsave(f, p, width=16, height=8)

# ppv cpm
x <- st_geomx_bgcorrect(ds, method="kdeppv", bw.adjust=bw.adjust, bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_ppv_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_ppv_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_ppv_boxplot.pdf")
# ggsave(f, p, width=16, height=8)

# bgsub cpm
x <- st_geomx_bgcorrect(ds, method="bgsub", bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_bgsub_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_bgsub_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_bgsub_boxplot.pdf")
# ggsave(f, p, width=16, height=8)



```


## BG correction version 4

```{r bgcorrect v4}

# parameters
eps <- 1e-10
n <- 2^13
bw.adjust <- 2
bg.quant <- 0.0

# choose sample
sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:10]

s <- c(ds$samples %>% slice_max(bg_auc, n=10) %>% pull(aoi), 
       ds$samples %>% slice_min(bg_auc, n=10) %>% pull(aoi))

for (i in s) {
  print(i)

  # setup
  bg <- ds$meta$bg
  x <- log2(unlist(ds$counts[,i]))
  xmin <- min(x)
  xmax <- max(x)
  
  expressed <- !bg & (x > quantile(x[bg], bg.quant))
  table(bg, expressed)
  
  # select bandwidth
  bwgene <- bw.nrd0(x[expressed]) * bw.adjust
  bwbg <- bw.nrd0(x[bg]) * bw.adjust
  bw <- max(bwgene, bwbg)
  
  d <- density(x[expressed], bw=bw, from=xmin, to=xmax, n=n)
  dcdf <- cumsum(d$y) / sum(d$y)
  
  dbg <- density(x[bg], bw=bw, from=xmin, to=xmax, n=n)
  dbgcdf <- cumsum(dbg$y) / sum(dbg$y)
  
  # false omission rate (FOR)
  dp <- dcdf / (dbgcdf + dcdf + eps)
  dp <- (dp - min(dp)) / (max(dp) - min(dp))
  
  # ensure isotonic behavior
  dp.ir <- isoreg(d$x, dp)$yf
  
  # interpolate
  p <- approx(d$x, dp.ir, xout=x, ties="ordered")$y
  #f <- splinefun(d$x, dp.ir, method="natural", ties="ordered")
  #p <- f(x)
  
  # transform
  y <- (2^x) * p
  y <- pmax(1, y)
  
  tbl <- bind_cols(dx = d$x,
                   dcdf = dcdf,
                   dbgcdf = dbgcdf,
                   dfor = dfor,
                   dp = dp,
                   dp.ir = dp.ir)
  
  ggplot(tbl) +
    geom_line(aes(dx, dcdf)) +
    geom_line(aes(dx, dbgcdf), color="red") +
    geom_line(aes(dx, dp), color="blue", alpha=0.8) +
    geom_line(aes(dx, dp.ir), color="blue", linetype="dashed", alpha=0.8) +
    geom_vline(xintercept=median(x[bg]), color="red", linetype="dashed", alpha=0.5)
  
  
  tbl <- bind_cols(x = 2^x, 
                   y = y)
  print(ggplot(tbl) +
    geom_line(aes(x, x), color="black", alpha=0.5) +
    geom_line(aes(x, y), color="red", alpha=0.5) + 
    scale_x_log10() +
    scale_y_log10())

}



# choose samples
sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:10]
s <- c(ds$samples %>% slice_max(bg_auc, n=10) %>% pull(aoi), 
       ds$samples %>% slice_min(bg_auc, n=10) %>% pull(aoi))

bg <- ds$meta$bg

for (i in s) {
  print(i)
  x <- unlist(ds$counts[,i])
  #res <- bgcorrect_kdeppv(x, bg, bw.adjust=2, bg.quant=0.5)
  #res <- bgcorrect_kdefor(x, bg, bw.adjust=2, bg.quant=0.5)

  tbl <- bind_cols(dx = res$dx,
                   dcdf = res$dcdf,
                   dbgcdf = res$dbgcdf,
                   dp = res$dp)

  print(ggplot(tbl) +
    geom_line(aes(dx, dcdf)) +
    geom_line(aes(dx, dbgcdf), color="red") +
    geom_line(aes(dx, dp), color="blue", alpha=0.8) +
    geom_vline(xintercept=median(log2(x)[bg]), color="red", linetype="dashed", alpha=0.5)
  )
  
  tbl <- bind_cols(x = x, 
                   y = res$y)
  print(ggplot(tbl) +
          geom_line(aes(x, x), color="black", alpha=0.5) +
          geom_line(aes(x, y), color="red", alpha=0.5) + 
          scale_x_log10() +
          scale_y_log10()
  )
  
}


```

## BG correction exploration

```{r bg correction exploration}

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:10]
s <- "s01_r3_panck"
x <- unlist(x[,s])


fitdistrplus::


bw.adjust <- 5

x <- log2(xs)
xmin <- min(x)
xmax <- max(x)

n <- 10000
bw <- bw.nrd0(x) * bw.adjust
eps <- 1e-10

dbg <- density(x[bg], bw=bw, from=xmin, to=xmax, n=n)

?quantile


#d <- density(x[!noise], bw=bw, from=xmin, to=xmax, n=n)

dcdf <- cumsum(d$y) / sum(d$y)
dbgcdf <- cumsum(dbg$y) / sum(dbg$y)
dbgcdf <- pmax(dbgcdf, dcdf)

dfdr <- (1-dbgcdf) / (1-dcdf+eps)
dfdr <- pmin(1, dfdr + fdr.min)
scaled_fdr <- xmin + (xmax - xmin) * cumsum(dfdr) / n
scaled_fdr <- pmin(d$x, scaled_fdr)
xnoise <- approx(d$x, scaled_fdr, xout=x)$y
xnoise <- pmin(xnoise, x)
y <- 2^x - 2^xnoise + 1

#dfdr <- (1-dbgcdf) / (1-dcdf)
#dfdr[which(is.nan(dfdr))] <- min(dfdr[which(!is.nan(dfdr))])
#dfdr <- pmin(1, dfdr + fdr.min)



res <- cluster_noise(xs, bg)

tbl <- bind_cols(x=res$x,
                 bg=res$bg_dist,
                 hi=res$hi_dist,
                 tot=res$bg_dist + res$hi_dist)

ggplot(tbl) +
  geom_point(aes(x,bg), color="red", alpha=0.5) +
  geom_point(aes(x,hi), color="blue", alpha=0.5) +
  geom_point(aes(x,tot)) +
  geom_vline(xintercept=res$bg_center, linetype="dashed", color="red") +
  geom_vline(xintercept=res$hi_center, linetype="dashed", color="blue") +
  geom_vline(xintercept=res$cutoff, linetype="dashed")


res <- bgcorrect_kdefdr2(xs, bg, bw.adjust=1, fdr.min=0.05)$y


for (s in ds$samples$aoi) {
  print(s)
  xs <- unlist(x[,s])
  res <- bgcorrect_kdefdr2(xs, bg, bw.adjust=1, fdr.min=0.05)$y
}



```

## DE exploration

```{r de lme4}
library(lmerTest)


# bgcorrect_method <- "bgsub"
# norm_method <- "qn"
# prefix <- paste0(bgcorrect_method, "_", norm_method)
# 
# x <- st_geomx_bgcorrect(fds, method=bgcorrect_method,
#                         bw.adjust=bgcorrect_bw_adjust,
#                         bg.quant=bgcorrect_bg_quant)
# x <- st_geomx_normalize(fds, x, method=norm_method)
# 
# 
# # design
# s <- filter(fds$samples, path_specimen == "inv")
# s$patient <- factor(s$patient)
# s$path_aoi <- factor(s$path_aoi, levels=c("nl", "lgd", "hgd", "inv"))
# 
# design <- model.matrix(~0 + path_aoi + patient, s)
# 
# colnames(design)
# 
# contrasts <- makeContrasts(inv_vs_nl = path_aoiinv - path_aoinl,
#                            hgd_vs_nl = path_aoihgd - path_aoinl,
#                            lgd_vs_nl = path_aoilgd - path_aoinl,
#                            levels=design)
# 
# y <- log2(x[,s$aoi])
# res <- run_limma_trend(y, design, contrasts, 
#                        padj_cutoff=de_padj_cutoff, 
#                        log2fc_cutoff=de_log2fc_cutoff,
#                        analysis=prefix)
# 
# res %>% arrange(desc(log2fc))
#
#
# run_limma_trend <- function(y, design, coef, padj_cutoff, log2fc_cutoff, 
#                             analysis, method) {
#   fit <- lmFit(y, design)
#   fit <- eBayes(fit, trend=TRUE)
#   res <- topTable(fit, coef=coef, number=Inf, sort.by="none")
#   res <- limma_rename_result_cols(res)
#   res <- de_format_results(res, analysis=analysis, method=method,
#                            padj_cutoff = padj_cutoff, log2fc_cutoff = log2fc_cutoff)
#   return(res)
# }

bgcorrect_method <- "bgsub"
bgcorrect_bw_adjust <- 2
bgcorrect_bg_quant <- 0.5
norm_method <- "rle"

x <- st_geomx_bgcorrect(fds, method=bgcorrect_method,
                        bw.adjust=bgcorrect_bw_adjust,
                        bg.quant=bgcorrect_bg_quant)
x <- st_geomx_normalize(fds, x, method=norm_method)


# setup for de analysis
s <- filter(fds$samples, path_specimen == "inv")
s$patient <- factor(s$patient)
s$path_aoi <- factor(s$path_aoi, levels=c("nl", "lgd", "hgd", "inv"))
y <- log2(x[,s$aoi])

g <- "KRT17"

tbl <- bind_cols(select(s, patient, path_aoi), y=y[g,])

fit <- lmerTest::lmer(y ~ path_aoi + (1|patient), data=tbl)
summary(fit)
ls_means(fit)

# Now check the anova-output:
lmer1 <- lmer(sweet~product+(1|assessor), data=sensintro)
anova(lmer1)


# Analysing all 20 assessors:
lmer1 <- lmer(sweet~product+(1|assessor), data=sensintro)
summary(lmer1)

design <- model.matrix(~0 + path_aoi + patient, s)
contrasts <- makeContrasts(inv_vs_nl = path_aoiinv - path_aoinl,
                           hgd_vs_nl = path_aoihgd - path_aoinl,
                           lgd_vs_nl = path_aoilgd - path_aoinl,
                           levels=design)

```
