---
title: "gmb_mel_tma_wta"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{gmb_mel_tma_wta}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r setup}
library(stgeomx)

library(tidyverse)
library(readxl)
library(writexl)
library(arrow)
library(limma)
library(edgeR)

library(patchwork)
library(ggrepel)
library(ggridges)
library(pheatmap)

save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
  stopifnot(!missing(x))
  stopifnot(!missing(filename))
  pdf(filename, width=width, height=height)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}

```


```{r input files, include=FALSE}

# master directory
working_dir <- "/Users/mkiyer/Library/CloudStorage/OneDrive-DukeUniversity/research/projects/st_mel"

# input directories
geomx_dir <- file.path(working_dir, "geomx")
data_dir <- file.path(working_dir, "external_data")

# melanoma tma wta data
geomx_mel_xlsx <- file.path(geomx_dir, "mel_tma_wta_2022-10-25.xlsx")
# sample annotation file
geomx_mel_annot_xlsx <- file.path(geomx_dir, "mel_tma_annot_2022_10-25.xlsx")

# human protein atlas melanoma signatures
hpa_mel_prog_xlsx <- file.path(data_dir, "hpa_melanoma_prognostic.xlsx")

# qc parameters
geomx_negprobe_lod_quantile = 0.9
geomx_min_counts = 1e6
geomx_min_auc = 0.70
geomx_aoi_min_frac_expr = 0.2
geomx_gene_min_frac_expr = 0.1

# normalization
bgcorrect_method = "qq"
bgcorrect_bw_adjust = 5
bgcorrect_bg_quant = 0.5
norm_method = "qn"

# de parameters
de_padj_cutoff <- 0.05
de_log2fc_cutoff <- 1

# gsea params
gsea_padj_cutoff <- 0.05
gsea_log2fc_cutoff <- 1

plot_dir <- file.path(working_dir, "plots")
if (!dir.exists(plot_dir)) {
  dir.create(plot_dir)
}

```

## Read and process geomx data

```{r geomx data, include=FALSE}

ds <- st_geomx_read_xlsx(geomx_mel_xlsx)
ds <- st_geomx_preprocess(ds, geomx_negprobe_lod_quantile)
ds <- st_geomx_merge_probes(ds)

# read and join sample annotation
annot <- read_excel(geomx_mel_annot_xlsx) %>%
  mutate(patient_sample = paste0(patient, "_", sample))

ds$samples <- ds$samples %>% 
  inner_join(annot, by="SegmentDisplayName")
```


## QC and filtering AOI / Genes

```{r choose filtering thresholds}

summary(ds$samples$num_counts)
summary(ds$samples$frac_expr)

ds <- st_geomx_set_thresholds(ds, 
                              min_counts = geomx_min_counts,
                              min_auc = geomx_min_auc,
                              aoi_min_frac_expr = geomx_aoi_min_frac_expr,
                              gene_min_frac_expr = geomx_gene_min_frac_expr)

table(ds$samples$keep)
table(ds$meta$expressed)

```

## QC: AOI filtering

```{r aoi filtering}

p <- st_geomx_plot_aoi_filter(ds, geomx_min_counts, geomx_min_auc, geomx_aoi_min_frac_expr)
p
ggsave(file.path(plot_dir, "qc_aoi_filter.pdf"), p)

```

## QC: gene filtering cutoff

```{r plot gene fraction detectable above bg}

p <- st_geomx_plot_gene_filter(ds, geomx_gene_min_frac_expr)
p
ggsave(file.path(plot_dir, "qc_gene_filtering_fpr_auc.pdf"), p)

```


## QC: Examine technical replicates

```{r technical replicates}

# make dataset with just technical replicates
s <- ds$samples %>%
  mutate(patient_sample = paste0(patient, "_", sample),
         replicate = paste0("rep", replicate)) %>%
  group_by(patient_sample) %>%
  filter(n() >=2) %>%
  ungroup() %>%
  arrange(patient_sample)

# pivot to compare replicates
x <- s %>%
  pivot_wider(id_cols = patient_sample, 
              names_from = replicate, 
              values_from = c(aoi, keep, bg_auc, bg_geomean, frac_expr, count_geomean, snr_geomean, num_counts))
x <- x %>%
  mutate(keep = case_when(keep_rep0 & keep_rep1 ~ "both",
                          keep_rep0 ~ "rep0",
                          keep_rep1 ~ "rep1",
                          TRUE ~ "none"))

cor.test(x$num_counts_rep0, x$num_counts_rep1)
p <- ggplot(x, aes(x=num_counts_rep0, y=num_counts_rep1)) +
  geom_point(aes(color=keep)) + 
  scale_color_manual(values = pals::cols25()) +
  geom_smooth(method='lm', formula= y~x) +
  geom_abline(slope=1, intercept=0, color='red', linetype='dashed') +
  scale_x_log10() +
  scale_y_log10() + 
  theme_minimal()
p
f <- file.path(plot_dir, "qc_techrep_scatter_numcounts.pdf")
ggsave(f, plot=p, device="pdf")

cor.test(x$bg_auc_rep0, x$bg_auc_rep1)
p <- ggplot(x, aes(x=bg_auc_rep0, y=bg_auc_rep1)) +
  geom_point(aes(color=keep)) + 
  scale_color_manual(values = pals::cols25()) +
  geom_smooth(method='lm', formula= y~x) +
  geom_abline(slope=1, intercept=0, color='red', linetype='dashed') +
  theme_minimal()
p
f <- file.path(plot_dir, "qc_techrep_scatter_auc.pdf")
ggsave(f, plot=p, device="pdf")

cor.test(x$frac_expr_rep0, x$frac_expr_rep1)
p <- ggplot(x, aes(x=frac_expr_rep0, y=frac_expr_rep1)) +
  geom_point(aes(color=keep)) + 
  scale_color_manual(values = pals::cols25()) + 
  geom_smooth(method='lm', formula= y~x) +
  geom_abline(slope=1, intercept=0, color='red', linetype='dashed') +
  theme_minimal()
p
f <- file.path(plot_dir, "qc_techrep_scatter_frac_expr.pdf")
ggsave(f, plot=p, device="pdf")


# correlation matrix
s0 <- s %>% filter(replicate == "rep0")
s1 <- s %>% filter(replicate == "rep1")
#s1 <- s %>% filter(replicate == "rep1", keep)
#s0 <- s %>% filter(replicate == "rep0", keep)
x0 <- ds$counts[, s0$aoi]
x1 <- ds$counts[, s1$aoi]
colnames(x0) <- s0$patient_sample
colnames(x1) <- s1$patient_sample
x <- cor(log2(x0), log2(x1), method = "spearman")

y <- as_tibble(x, rownames="s0") %>%
  pivot_longer(s1$patient_sample, names_to="s1", values_to="cor") %>%
  mutate(techrep = s0 == s1,
         p0 = str_split_fixed(s0, "_", 2)[,1],
         p1 = str_split_fixed(s1, "_", 2)[,1],
         samepatient = p0 == p1,
         cond = case_when(techrep ~ "techrep",
                          samepatient ~ "samepatient",
                          TRUE ~ "differentpatient")
  )
y$cond <- factor(y$cond, levels=c("differentpatient", "samepatient", "techrep"))


# distribution of correlation
p <- ggplot(y, aes(x=cor, y=cond, fill=cond)) +
  stat_density_ridges(alpha=0.6, scale=3, quantile_lines=TRUE) +
  scale_color_manual(values = pals::cols25())
p
f <- file.path(plot_dir, "qc_techrep_ridge_by_cond.pdf")
ggsave(f, plot=p, device="pdf")

# sort by condition
y <- y %>% arrange(cond, s0)

# reorder correlation matrix by condition
x <- x[unique(y$s0), unique(y$s0)]
p <- pheatmap(x,
         color = pals::brewer.ylorrd(100),
         breaks = seq(0, 1, length.out=101),
         border_color = NA,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         fontsize_row=4,
         fontsize_col=4)
f <- file.path(plot_dir, "heatmap_techrep_cor_matrix.pdf")
save_pheatmap_pdf(p, filename=f, width=8, height=8)


```

## QC: Background correction

```{r background correction, warning=FALSE}

# params for plot
quantiles=c(0.10, 0.25, 0.5, 0.75, 0.90, 0.99)
width <- 16
height <- 6
  
# params for bgcorrect
bw.adjust <- 5
bg.quant <- 0.5
ppv.max <- 0.95


## plots

# raw cpm
x <- as_tibble(cpm(ds$counts))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_none_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_none_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, xraw)
# f <- file.path(plot_dir, "qc_bgcorrect_none_boxplot.pdf")
# ggsave(f, p, width=width, height=8)

# qq cpm
x <- st_geomx_bgcorrect(ds, method="qq", bw.adjust=bw.adjust, bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_qq_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_qq_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_qq_boxplot.pdf")
# ggsave(f, p, width=16, height=8)

# ppv cpm
x <- st_geomx_bgcorrect(ds, method="kdeppv", bw.adjust=bw.adjust, ppv.max=ppv.max)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_ppv_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_ppv_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_ppv_boxplot.pdf")
# ggsave(f, p, width=16, height=8)

# bgsub cpm
x <- st_geomx_bgcorrect(ds, method="bgsub", bg.quant=bg.quant)
x <- as_tibble(cpm(x))
p <- st_geomx_plot_bg_dotplot(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_bgsub_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(ds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_bgsub_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# p <- st_geomx_plot_dist_boxplot(ds, x)
# f <- file.path(plot_dir, "qc_bgcorrect_bgsub_boxplot.pdf")
# ggsave(f, p, width=16, height=8)

  
```


## Apply filters and normalize

Consolidate technical replicates. When sample has replicates, choose replicate with greater signal-to-noise ratio

```{r filter and normalize}

# choose replicate with highest snauc
s <- ds$samples %>%
  filter(keep == TRUE) %>%
  group_by(patient_sample) %>%
  slice_max(bg_auc, n=1) %>%
  ungroup()

length(sort(table(s$patient_sample)))

table(ds$samples$has_replicate, ds$samples$keep)
length(unique(ds$samples$aoi))
length(unique(s$aoi))
table(s$keep)
table(ds$samples$keep)

fds <- list(samples = s,
            meta = ds$meta,
            counts = ds$counts[, s$aoi])

# apply filters
fds <- st_geomx_filter(fds)


# bg correct
bgcorrect_method <- "bgsub"
x <- st_geomx_bgcorrect(fds, 
                        method=bgcorrect_method,
                        bw.adjust=bgcorrect_bw_adjust, 
                        bg.quant=bgcorrect_bg_quant)
#x <- st_geomx_bgcorrect(fds, method="qq")
#x <- st_geomx_bgcorrect(fds, method="bgsub")
#x <- st_geomx_bgcorrect(fds, method="kdeppv", bw.adjust=bw.adjust, ppv.max=ppv.max)

# normalize
y_bg_qn <- st_geomx_normalize(fds, x, method="qn")
#y_bg_rle <- st_geomx_normalize(fds, x, method="rle")
#y_bg_cpm <- st_geomx_normalize(fds, x, method="cpm")

# choose normalized data to work with
normcounts <- y_bg_qn

length(unique(s$aoi))
length(unique(fds$samples$patient))
length(unique(fds$samples$aoi))
table(fds$samples$slide)
table(fds$samples$sample_type)
table(fds$samples$acral)

# write gene expression data
write_xlsx(
  list(unfiltered_samples = ds$samples,
       filtered_samples = fds$samples,
       norm_gene_expr = as_tibble(normcounts, rownames="gene")), 
  file.path(working_dir, 'st_mel_roi_annot.xlsx')
)

write_xlsx(ds$samples, file.path(working_dir, 'st_mel_roi_annot.xlsx'))


```


```{r check normalization}

# bgcorrect plots
x <- as_tibble(cpm(normcounts))
p <- st_geomx_plot_bg_dotplot(fds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_dotplot.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)
p <- st_geomx_plot_bg_scatter(fds, x, quantiles)
f <- file.path(plot_dir, "qc_bgcorrect_scatter.pdf")
ggsave(f, plot=p, device="pdf", width=width, height=height)

# pca
y <- log2(normcounts)
pca_res <- prcomp(t(y), center=TRUE, scale=TRUE)
pca_tbl <- bind_cols(fds$samples, as_tibble(pca_res$x))
pct_var <- pca_res$sdev^2 / sum(pca_res$sdev^2)
pct_var_lbl <- round(100 * pct_var, 2)
pct_var_lbl <- paste(colnames(pca_res$x), " (", paste(as.character(pct_var_lbl), "%", ")", sep=""), sep="")

score <- (abs(cor(pca_tbl$PC1, pca_tbl$bg_ks_dist)) * pct_var[1] +
            abs(cor(pca_tbl$PC2, pca_tbl$bg_ks_dist)) * pct_var[2] +
            abs(cor(pca_tbl$PC3, pca_tbl$bg_ks_dist)) * pct_var[3] +
            abs(cor(pca_tbl$PC4, pca_tbl$bg_ks_dist)) * pct_var[4])
score

ggplot(pca_tbl, aes(bg_ks_dist, PC1)) + 
  geom_point() + 
  geom_smooth(method='lm', formula= y~x) +
  labs(y=pct_var_lbl[1], title=cor.test(pca_tbl$PC1, pca_tbl$bg_ks_dist)$estimate)
ggplot(pca_tbl, aes(bg_ks_dist, PC2)) + 
  geom_point() + 
  geom_smooth(method='lm', formula= y~x) +
  labs(y=pct_var_lbl[2], title=cor.test(pca_tbl$PC2, pca_tbl$bg_ks_dist)$estimate)
ggplot(pca_tbl, aes(bg_ks_dist, PC3)) + 
  geom_point() + 
  geom_smooth(method='lm', formula= y~x) +
  labs(y=pct_var_lbl[3], title=cor.test(pca_tbl$PC3, pca_tbl$bg_ks_dist)$estimate)

p <- ggplot(pca_tbl, aes(x=PC1, y=PC2)) +
  theme_minimal() +
  labs(x=pct_var_lbl[1], y=pct_var_lbl[2], title=100*score) +
  geom_point(aes(color=bg_ks_dist), alpha = 0.8, size=2) +
  scale_color_viridis_c()
p


# cor.test(pca_tbl$PC1, pca_tbl$bg_cpm)
# cor.test(pca_tbl$PC2, pca_tbl$bg_cpm)
# cor.test(pca_tbl$PC3, pca_tbl$bg_cpm)


```



## QC plot: normalization

```{r qc normalization}

# sample annotations to use in plots
s <- select(fds$samples, aoi, slide, keep, acral, sample_type, os_quartile, vital_status)
x <- bind_cols(fds$meta, normcounts)
x <- x %>%
  pivot_longer(s$aoi, names_to="aoi", values_to="count") %>%
  inner_join(s, by=c("aoi"="aoi"), suffix=c("_gene", "_aoi"))

y <- x %>%
  group_by(aoi, expressed) %>%
  summarise(slide = unique(slide),
            med = median(count),
            q3 = quantile(count, 0.75)) %>%
  ungroup()

p <- ggplot(x, aes(x=count, y=reorder(aoi, count), fill=slide)) +
  stat_density_ridges(color="#00000066", alpha=0.4, scale=10, rel_min_height=0.001, quantile_lines=TRUE) +
  scale_x_log10() +
  scale_fill_manual(values = pals::cols25()) +
  xlab("Count") +
  ylab("AOIs") +
  labs(fill = "Slide") +
  theme_ridges() +
  theme(axis.text.y = element_blank()) +
  facet_grid(slide ~ ., scales="free_y")
p
f <- file.path(plot_dir, "qc_ridge_plot_norm_aoi.pdf")
ggsave(f, plot=p, device="pdf", width = 8, height = 8)


# by acral
p <- x %>%
  ggplot(aes(x=count, y=factor(acral), fill=factor(acral))) +
  stat_density_ridges(alpha=0.7, scale=3, rel_min_height=0.001, quantile_lines=TRUE) + 
  scale_color_manual(values = pals::cols25()) + 
  scale_x_log10() +
  theme_ridges() + 
  theme(axis.text = element_text(size=5))
p
f <- file.path(plot_dir, "qc_ridge_plot_norm_acral.pdf")
ggsave(f, plot=p, device="pdf", width = 8, height = 8)


# by sample_type
p <- x %>%
  ggplot(aes(x=count, y=sample_type, fill=sample_type)) +
  stat_density_ridges(alpha=0.5, scale=3, rel_min_height=0.001, quantile_lines=TRUE) + 
  scale_color_manual(values = pals::cols25()) +
  scale_x_log10() +
  theme_ridges() + 
  theme(axis.text = element_text(size=5))
p
f <- file.path(plot_dir, "qc_ridge_plot_norm_sample_type.pdf")
ggsave(f, plot=p, device="pdf", width = 8, height = 8)


# by survival
p <- x %>%
  ggplot(aes(x=count, y=os_quartile, fill=factor(os_quartile))) +
  stat_density_ridges(alpha=0.5, scale=3, rel_min_height=0.001, quantile_lines=TRUE) + 
  scale_color_manual(values = pals::cols25()) +
  scale_x_log10() +
  theme_ridges() + 
  theme(axis.text = element_text(size=5))
p
f <- file.path(plot_dir, "qc_ridge_plot_norm_sample_type.pdf")
ggsave(f, plot=p, device="pdf", width = 8, height = 8)


```


## Unsupervised clustering / dimensionality reduction

```{r dim reduction}
library(factoextra)
library(umap)

most_cv_genes <- function(x, ntop=500) {
  rv <- apply(x, 1, function(x) sd(x) / mean(x))
  keep <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  return(x[keep,])
}

run_pca <- function(x) {
  pca <- prcomp(t(x))
  pct_var <- round(100 * pca$sdev^2 / sum( pca$sdev^2 ), 2)
  pct_var <- paste(colnames(pca$x), " (", paste(as.character(pct_var), "%", ")", sep=""), sep="")
  return(list(pca = pca, pct_var = pct_var))
}


y <- log2(normcounts)
y <- most_cv_genes(y, 5000)

pca_res <- run_pca(y)
pca_tbl <- bind_cols(fds$samples, as_tibble(pca_res$pca$x))

# pca plots
p <- ggplot(pca_tbl, aes(x=PC1, y=PC2)) +
  theme_minimal() +
  labs(x=pca_res$pct_var[1], y=pca_res$pct_var[2])

# qc factors
p1 <- p + geom_point(aes(color=bg_auc), alpha = 0.8, size=2) +
  scale_color_viridis_c()
p1
ggsave(file.path(plot_dir, "pca_bg_auc.pdf"), plot=p1, device="pdf")

# biological factors
#p1 <- p + geom_point(aes(color=factor(patient)), alpha = 0.8, size=2)
#p1
p1 <- p + geom_point(aes(color=factor(acral)), alpha = 0.8, size=2) +
  scale_color_manual(values=pals::cols25())
p1
ggsave(file.path(plot_dir, "pca_acral.pdf"), plot=p1, device="pdf")

p1 <- p + geom_point(aes(color=factor(sample_type)), alpha = 0.8, size=2) +
  scale_color_manual(values=pals::cols25())
p1
ggsave(file.path(plot_dir, "pca_sample_type.pdf"), plot=p1, device="pdf")

p1 <- p + geom_point(aes(color=factor(os_quartile)), alpha = 0.8, size=2) +
  scale_color_manual(values=pals::cols25())
p1
ggsave(file.path(plot_dir, "pca_os_quartile.pdf"), plot=p1, device="pdf")

# investigate contributions to pca
res.pca <- prcomp(y, scale = TRUE)
p <- fviz_pca_ind(res.pca, select.ind=list(contrib=20), repel=TRUE, ggrepel.max.overlaps=Inf)
p
ggsave(file.path(plot_dir, "pca_ind.pdf"), p)

p <- fviz_contrib(res.pca, choice = "ind", axes = 1, top=20, max.overlaps=Inf)
p
ggsave(file.path(plot_dir, "pca_contrib.pdf"), p)


# UMAP variable genes
umap_fit <- t(y) %>%
   scale() %>% 
   umap()
umap_df <- umap_fit$layout %>%
   as.data.frame() %>%
   dplyr::rename(umap1 = "V1",
                 umap2 = "V2")
umap_df <- bind_cols(fds$samples, umap_df)


p <- ggplot(umap_df, aes(x=umap1, y=umap2)) +
  theme_minimal()

p1 <- p + geom_point(aes(color=bg_auc), alpha = 0.8, size=2) +
  scale_color_viridis_c()
p1

# biological factors
#p1 <- p + geom_point(aes(color=factor(patient)), alpha = 0.8, size=2)
#p1
p1 <- p + geom_point(aes(color=factor(acral)), alpha = 0.8, size=2) +
  scale_color_manual(values=pals::cols25())
p1
p1 <- p + geom_point(aes(color=factor(sample_type)), alpha = 0.8, size=2) +
  scale_color_manual(values=pals::cols25())
p1
p1 <- p + geom_point(aes(color=factor(os_quartile)), alpha = 0.8, size=2) +
  scale_color_manual(values=pals::cols25())
p1


```

## Clustering high variance genes

```{r}
library(pheatmap)

y <- log2(normcounts)
y <- most_cv_genes(y, 5000)

s <- fds$samples %>% mutate(noise_quantile = ntile(desc(bg_auc), 4))


annot_col <- column_to_rownames(s, "aoi") %>% 
  select(sample_type = sample_type,
         acral = acral, 
         os_quartile = os_quartile,
         slide = slide,
         noise_quantile = noise_quantile) %>%
  as.data.frame()

f <- file.path(plot_dir, "heatmap_cluster_highcv_genes.png")
width <- 12
height <- 8

p <- pheatmap(y,
         scale="row",
         show_rownames=FALSE,
         show_colnames=FALSE,
         border_color=NA,
         clustering_method = "average",
         clustering_distance_rows = "correlation",
         clustering_distance_cols = "correlation",
         breaks = seq(-3, 3, 0.05),
         color = colorRampPalette(c("purple3", "black", "yellow2"))(120),
         annotation_col = annot_col,
         filename=f, width=width, height=height)

f <- file.path(plot_dir, "heatmap_cluster_highcv_genes.pdf")
save_pheatmap_pdf(p, filename=f, width=width, height=height)



```


## Differential expression analysis

```{r de analysis setup}

limma_rename_result_cols <- function(res) {
  as_tibble(res, rownames="gene") %>%
    select(gene,
           log2fc=logFC,
           avgexpr=AveExpr,
           pval=P.Value,
           padj=adj.P.Val)
}

de_format_results <- function(res, analysis, method, 
                              padj_cutoff, log2fc_cutoff) {
  mutate(res, 
         de = case_when(padj > padj_cutoff ~ "no",
                        log2fc < -log2fc_cutoff ~ "dn",
                        log2fc > log2fc_cutoff ~ "up",
                        TRUE ~ "no"),
         analysis = analysis,
         method = method)
}

run_limma_trend <- function(y, design, contrasts) {
  fit <- lmFit(y, design)
  fit <- contrasts.fit(fit, contrasts)
  fit <- eBayes(fit, trend=TRUE)
  return(fit)
}

process_limma <- function(fit, contrasts, method, 
                          padj_cutoff, log2fc_cutoff) {
  x <- NULL
  for (coef in colnames(contrasts)) {
    res <- topTable(fit, coef=coef, number=Inf, sort.by="none")
    res <- limma_rename_result_cols(res)
    res <- de_format_results(res, 
                             analysis=coef, 
                             method=method,
                             padj_cutoff=padj_cutoff, 
                             log2fc_cutoff=log2fc_cutoff)
    x <- bind_rows(x, res)
  }
  return(x)
}


plot_de_volcano <- function(res) {
  # res <- res %>% 
  #   mutate(de = case_when(padj > 0.05 ~ "no",
  #                         log2fc < 0 ~ "dn",
  #                         log2fc > 0 ~ "up"))
  p <- ggplot(res, aes(x=log2fc, y=-log10(padj), color=de, size=de)) +
    geom_point(alpha=0.7) +
    geom_text_repel(data=subset(res, de != "no"), color="black", size=3, aes(label=gene), max.overlaps=Inf) +
    scale_color_manual(values=c("no"="grey", "dn"="blue", "up"="red")) +
    scale_size_manual(values=c("no"=1, "dn"=2, "up"=2)) +
    theme_minimal() +
    theme(legend.position="bottom") + 
    theme(axis.line = element_line(color = "black"))
    labs(x="log2fc", y="-log10(padj)")
  return(p)
}


```


## DE analysis in transit melanoma 

```{r between patient de analysis}

# assemble cohort of in-transit disease with one sample per patient
s <- fds$samples %>%
  filter(sample_type == "it") %>%
  group_by(patient) %>%
  arrange(sample_type) %>%
  slice_head(n=1) %>%
  ungroup()
y <- log2(normcounts)[,s$aoi]


# de analysis
de <- NULL
method <- "limma_trend"

# acral
s$acral <- factor(s$acral, levels=c(0, 1))

design <- stats::model.matrix(~0 + acral, data=s)
contrasts <- limma::makeContrasts(acral = acral1 - acral0,
                                  levels=design)
fit <- run_limma_trend(y, design, contrasts)
res <- process_limma(fit, contrasts, method, de_padj_cutoff, de_log2fc_cutoff) 
de <- bind_rows(de, res)

p <- plot_de_volcano(res) +
  labs(title = "Acral vs. Non-Acral")
p
ggsave(file.path(plot_dir, "de_volcano_acral.pdf"), p)
ggsave(file.path(plot_dir, "de_volcano_acral.png"), p)


# Survival 3yr
analysis <- "os_3yr"
s$os_3yr <- factor(ifelse(s$os_quartile < 1, "under3yrs", "over3yrs"), levels=c("over3yrs", "under3yrs"))

design <- stats::model.matrix(~ 0 + os_3yr, data=s)
colnames(design) <- levels(s$os_3yr)
contrasts <- limma::makeContrasts(os3yr = under3yrs - over3yrs,
                                  levels=design)

fit <- run_limma_trend(y, design, contrasts)
res <- process_limma(fit, contrasts, method, de_padj_cutoff, de_log2fc_cutoff) 
de <- bind_rows(de, res)
p <- plot_de_volcano(res) + ggtitle("OS <3yr vs >3yr")
p
ggsave(file.path(plot_dir, "de_volcano_os_3yr.png"), p)
ggsave(file.path(plot_dir, "de_volcano_os_3yr.pdf"), p)


# Survival 5yr
analysis <- "os_5yr"
s$os_5yr <- factor(ifelse(s$os_quartile < 2, "under5yrs", "over5yrs"), levels=c("over5yrs", "under5yrs"))

design <- stats::model.matrix(~ 0 + os_5yr, data=s)
colnames(design) <- levels(s$os_5yr)
contrasts <- limma::makeContrasts(os5yr = under5yrs - over5yrs,
                                  levels=design)

fit <- run_limma_trend(y, design, contrasts)
res <- process_limma(fit, contrasts, method, de_padj_cutoff, de_log2fc_cutoff) 
de <- bind_rows(de, res)
p <- plot_de_volcano(res) + ggtitle("OS <5yr vs >5yr")
p



# Survival 9 yr
analysis <- "os_9yr"
s$os_9yr <- factor(ifelse(s$os_quartile < 3, "under9yrs", "over9yrs"), levels=c("over9yrs", "under9yrs"))

design <- stats::model.matrix(~ 0 + os_9yr, data=s)
colnames(design) <- levels(s$os_9yr)
contrasts <- limma::makeContrasts(os9yr = under9yrs - over9yrs,
                                  levels=design)
fit <- run_limma_trend(y, design, contrasts)
res <- process_limma(fit, contrasts, method, de_padj_cutoff, de_log2fc_cutoff) 
de <- bind_rows(de, res)
p <- plot_de_volcano(res) + ggtitle("OS <9yr vs >9yr")
p
ggsave(file.path(plot_dir, "de_volcano_os9yr.pdf"), p)
ggsave(file.path(plot_dir, "de_volcano_os9yr.png"), p)



# Survival q0 vs q3
table(s$os_quartile)

s$os_quartile <- factor(s$os_quartile)
design <- stats::model.matrix(~ 0 + os_quartile, data=s)
contrasts <- limma::makeContrasts(os_q0_vs_q3 = os_quartile0 - os_quartile3,
                                  levels=design)
fit <- run_limma_trend(y, design, contrasts)
res <- process_limma(fit, contrasts, method, de_padj_cutoff, de_log2fc_cutoff) 

de <- bind_rows(de, res)
table(res$analysis)
p <- plot_de_volcano(res) + ggtitle("OS <3yr vs >9yr")
p
ggsave(file.path(plot_dir, "de_volcano_os_q0_vs_q3.pdf"), p)
ggsave(file.path(plot_dir, "de_volcano_os_q0_vs_q3.png"), p)

# write gene expression data
write_xlsx(de, file.path(working_dir, 'de_results_it.xlsx'))


de_genes <- unique(filter(de, de != "no") %>% pull(gene))
de_expr <- y[de_genes,]
exprs <- bind_cols(s, t(de_expr))

write_xlsx(
  list(mel_it_de_genes = exprs),
  file.path(working_dir, 'de_gene_expr.xlsx')
)




```

## plot individual genes

```{r plot genes}

plot_gene <- function(s, x, gene, aes_x, aes_color) {
  exprs <- unlist(x[gene, ])
  x <- s %>% add_column(gene = exprs)
  p <- ggplot(x, aes(x={{ aes_x }}, y=gene, fill={{aes_color}})) +
    geom_boxplot(outlier.shape = NA, width=0.5) +
    geom_point(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.5)) +
    scale_fill_manual(values=pals::cols25()) +
    ggtitle(paste0("Gene: ", gene)) +
    theme_minimal() + 
    theme(axis.text.x = element_text(color = "black", angle = 90, vjust = 0.5, hjust=1)) +
    theme(axis.line = element_line(color = "black"))
  return(p)
}


de_genes <- filter(de, analysis=="acral", de != "no") %>% pull(gene)
for (g in de_genes) {
  p <- plot_gene(s, y, g, acral, acral)
  f <- paste0("gene_acral_", g, ".png")
  ggsave(file.path(plot_dir, f), p)
}


de_genes <- filter(de, analysis=="os3yr", de != "no") %>% pull(gene)
for (g in de_genes) {
  p <- plot_gene(s, y, g, os_quartile, os_quartile)
  f <- paste0("gene_os3yr_", g, ".png")
  ggsave(file.path(plot_dir, f), p)
}



```



## GSEA

```{r gsea}
library(msigdbr)
library(fgsea)
library(GSVA)

# read msigdb data and subset to expressed genes in dataset
msigdb_gene_sets = msigdbr(species = "Homo sapiens")
msigdb_gene_sets <- filter(msigdb_gene_sets, gene_symbol %in% fds$meta$gene) 

# analysis across specific msigdb gene sets
gs_hallmark <- filter(msigdb_gene_sets, gs_cat == "H")
gs_hallmark <- split(x = gs_hallmark$gene_symbol, f = gs_hallmark$gs_name)
gs_gobp <- filter(msigdb_gene_sets, gs_cat == "C5", gs_subcat == "GO:BP")
gs_gobp <- split(x = gs_gobp$gene_symbol, f = gs_gobp$gs_name)
gs_msigdb <- split(x = msigdb_gene_sets$gene_symbol, f = msigdb_gene_sets$gs_name)

get_de_ranks <- function(de, a) {
  ranks <- de %>% 
    filter(analysis == a) %>%
    select(gene, log2fc, padj) %>%
    mutate(rank = log2fc)
  ranks = sort(setNames(ranks$rank, ranks$gene), decreasing = TRUE)
  return(ranks)
}

plot_gsea_enrichment <- function(x, ranks, gs) {
  txt_stat <- paste0("ES=", round(x$ES,2), " NES=", round(x$NES, 2), " padj=", format(x$padj, scientific=TRUE, digits=3))
  txt_title <- paste0("Gene set: ", x$pathway)
  p <- plotEnrichment(gs[[x$pathway]], ranks) +
    annotate(geom="text", x=150, y=0.1, label=txt_stat, hjust=0) +
    labs(title = txt_title, 
         xlab = "Rank",
         ylab = "Enrichment Score") +
    theme(plot.title = element_text(size=8))
  return(p)
}

plot_gsea_barplot <- function(x, padj_cutoff = 0.01) {
  x <- mutate(x, sig = ifelse(padj < padj_cutoff, ifelse(NES < 0, "dn", "up"), "no"),
              neglog10padj = ifelse(padj < padj_cutoff, -log10(padj), NA))
  x <- mutate(x, sig = ifelse(padj < padj_cutoff, ifelse(NES < 0, "dn", "up"), "no"),
              neglog10padj = -log10(padj))
  p <- ggplot(x, aes(x=reorder(pathway, NES), y=NES, fill=neglog10padj, color=sig)) +
    geom_col() +
    scale_fill_gradient(low = "cyan", high = "blue", na.value="#aaaaaa") +
    scale_color_manual(values = c("up" = "red", "dn" = "red", "no" = "#ffffff00")) +
    coord_flip() +
    labs(x="Analysis", y="Normalized Enrichment Score") +
    theme_minimal()
  return(p)
}


run_batch_fgsea <- function(my_analyses, my_de, my_gs, my_prefix, my_plot_dir, my_padj_cutoff=0.01) {
  gsea <- NULL
  for (a in my_analyses) {
    ranks <- get_de_ranks(my_de, a)
    res <- fgsea(pathways = my_gs, stats = ranks, minSize = 10, eps = 0, nPermSimple = 10000)
    res <- mutate(res, analysis = a)
    gsea <- bind_rows(gsea, res)
    print(a)
    # for (i in 1:nrow(res)) {
    #   x <- res[i,]
    #   if (x$padj >= my_padj_cutoff) { next }
    #   print(x$pathway)
    #   p <- plot_gsea_enrichment(x, ranks, my_gs)
    #   f <- file.path(my_plot_dir, paste0(my_prefix, "_", a, "_gs_", x$pathway, ".pdf"))
    #   ggsave(f, plot=p, device="pdf", width=5, height=3)
    # }
  }
  return(gsea)
}


# human protein atlas prognostic genes 
gs_hpa = list()
hpa_mel_prog_unfav <- read_xlsx(hpa_mel_prog_xlsx, sheet="unfav") %>%
  filter(Gene %in% fds$meta$gene)
hpa_mel_prog_fav <- read_xlsx(hpa_mel_prog_xlsx, sheet="fav") %>%
  filter(Gene %in% fds$meta$gene)
gs_hpa$hpa_mel_prog_unfav <- hpa_mel_prog_unfav %>% pull(Gene)
gs_hpa$hpa_mel_prog_fav  <- hpa_mel_prog_fav  %>% pull(Gene)

# run fgsea
analyses <- unique(de$analysis)

# gsea hpa
prefix <- "gsea_hpa"
padj_cutoff <- 0.05
gsea <- run_batch_fgsea(analyses, de, gs_hpa, prefix, plot_dir, padj_cutoff)
gsea <- as_tibble(gsea)

# plot acral fav/unfav prognosis
x <- filter(gsea, pathway == "hpa_mel_prog_fav", analysis == "acral")
p <- plot_gsea_enrichment(x, get_de_ranks(de, "acral"), gs_hpa)
ggsave(file.path(plot_dir, "gsea_acral_hpa_mel_prog_fav.pdf"), p, width=4, height=3)

x <- filter(gsea, pathway == "hpa_mel_prog_unfav", analysis == "acral")
p <- plot_gsea_enrichment(x, get_de_ranks(de, "acral"), gs_hpa)
ggsave(file.path(plot_dir, "gsea_acral_hpa_mel_prog_unfav.pdf"), p, width=4, height=3)

# plot os3yr fav/unfav prognosis
x <- filter(gsea, pathway == "hpa_mel_prog_fav", analysis == "os3yr")
p <- plot_gsea_enrichment(x, get_de_ranks(de, "os3yr"), gs_hpa)
ggsave(file.path(plot_dir, "gsea_os3yr_hpa_mel_prog_fav.pdf"), p, width=4, height=3)

x <- filter(gsea, pathway == "hpa_mel_prog_unfav", analysis == "os3yr")
p <- plot_gsea_enrichment(x, get_de_ranks(de, "os3yr"), gs_hpa)
ggsave(file.path(plot_dir, "gsea_os3yr_hpa_mel_prog_unfav.pdf"), p, width=4, height=3)



# gsea hallmark
prefix <- "gsea_hallmark"
gsea <- run_batch_fgsea(analyses, de, gs_hallmark, prefix, plot_dir, padj_cutoff)
gsea <- as_tibble(gsea)

p <- plot_gsea_barplot(filter(gsea, analysis == "acral"), padj_cutoff = padj_cutoff)
ggsave(file.path(plot_dir, "gsea_hallmark_acral.pdf"), p, height=8)

p <- plot_gsea_barplot(filter(gsea, analysis == "os3yr"), padj_cutoff = padj_cutoff)
ggsave(file.path(plot_dir, "gsea_hallmark_os3yr.pdf"), p, height=8)


# gsea gobp
prefix <- "gsea_gobp"
gsea <- run_batch_fgsea(analyses, de, gs_gobp, prefix, plot_dir, padj_cutoff)
gsea <- as_tibble(gsea)

x <- filter(gsea, analysis == "acral")
top25up <- x %>%
  filter(padj < gsea_padj_cutoff) %>%
  slice_max(NES, n = 25) %>%
  arrange(desc(NES)) %>%
  pull(pathway)
top25dn <- x %>%
  filter(padj < gsea_padj_cutoff) %>%
  slice_min(NES, n = 25) %>%
  arrange(desc(NES)) %>%
  pull(pathway)
top50pathways <- unique(c(top25up, top25dn))

x <- x %>% filter(pathway %in% top50pathways)
x$pathway <- gsub("GOBP_", "", x$pathway)
x$pathway <- substr(x$pathway, 1, 50)

p <- plot_gsea_barplot(x) +
  labs(title = "GOBP gene sets")
ggsave(file.path(plot_dir, "gsea_gobp_acral.pdf"), p, height=8)


x <- filter(gsea, analysis == "os3yr")
top25up <- x %>%
  filter(padj < gsea_padj_cutoff) %>%
  slice_max(NES, n = 25) %>%
  arrange(desc(NES)) %>%
  pull(pathway)
top25dn <- x %>%
  filter(padj < gsea_padj_cutoff) %>%
  slice_min(NES, n = 25) %>%
  arrange(desc(NES)) %>%
  pull(pathway)
top50pathways <- unique(c(top25up, top25dn))

x <- x %>% filter(pathway %in% top50pathways)
x$pathway <- gsub("GOBP_", "", x$pathway)
x$pathway <- substr(x$pathway, 1, 50)

p <- plot_gsea_barplot(x) +
  labs(title = "GOBP gene sets")
ggsave(file.path(plot_dir, "gsea_gobp_os3yr.pdf"), p, height=8)



# gsea msigdb
analyses <- c("acral", "os3yr")
prefix <- "gsea_msigdb"
gsea <- run_batch_fgsea(analyses, de, gs_msigdb, prefix, plot_dir, padj_cutoff)
gsea <- as_tibble(gsea)

# write gsea results
f <- file.path(working_dir, paste0("gsea_msigdb_", analysis, "_results.xlsx"))
write_xlsx(gsea, f)

gsea %>% filter(pathway == "GOCC_PIGMENT_GRANULE") %>% pull(leadingEdge)



```

## ssgsea plots

```{r }
library(GSVA)

# assemble cohort of in-transit disease with one sample per patient
s <- fds$samples %>%
  filter(sample_type == "it") %>%
  group_by(patient) %>%
  arrange(sample_type) %>%
  slice_head(n=1) %>%
  ungroup()
y <- log2(normcounts)[,s$aoi]

# run gsva
score_method <- "ssgsea"
gs_list <- c(gs_hpa, gs_hallmark)
gs_scores <- gsva(y, gs_list, method=score_method)

# waterfall color scheme
# color_scheme <- setNames(pals::plasma(nlevels(s$response_category)), levels(s$response_category))

x <- bind_cols(s, score = gs_scores["HALLMARK_INTERFERON_GAMMA_RESPONSE",])

colnames(s)

ggplot(x, aes(x=os_years, y=score, color=factor(os_quartile))) +
  geom_point()


p <- ggplot(y, aes(x=reorder(study, picard_pct_intergenic_bases), 
                   y=picard_pct_intergenic_bases, fill=study)) +
  geom_boxplot(width = 0.75) +
  geom_jitter(size = 1, width = 0.1, alpha = 0.6) +
  theme(axis.text.x = element_text(color = "black", angle = 90, vjust=0.5, hjust=1, size=6)) +
  theme(legend.position="bottom") +
  labs(title="Percent Intergenic Bases", subtitle="indicates DNA contamination",
       x="Study", y="%")





```



## QC plots: count distributions

```{r background noise by aoi}

# sample annotations to use in plots
st_geomx_plot_count_distribution(ds, sample_type, sample_type)


```


## Misc QC plots

```{r misc qc plots}

p <- ggplot(ds$samples, aes(x=ROICoordinateX, y=ROICoordinateY, color=bg_auc)) +
  geom_point() +
  scale_color_viridis_c() +
  facet_wrap(~ slide)
p


p <- ggplot(ds$samples, aes(x=num_counts, y=frac_expr, color=slide)) +
  geom_point(alpha=0.6) +
  geom_hline(yintercept = geomx_aoi_min_frac_expr, linetype = "dashed", color = "red") +
  geom_vline(xintercept = geomx_min_counts, linetype = "dashed", color = "red") +
  scale_color_manual(values = pals::cols25()) +
  scale_x_log10() +
  labs(x="Counts", y="Frac detectable genes", 
       title="Counts vs Frac detectable genes") +
  theme_minimal()
p
ggsave(file.path(plot_dir, "geomx_scatter_counts_vs_frac_expr.pdf"), p)
p + facet_wrap(~ slide)
ggsave(file.path(plot_dir, "geomx_scatter_counts_vs_frac_expr_byslide.pdf"), p)

# figure: AOINucleiCount versus num_counts
p <- ggplot(ds$samples, aes(x=AOINucleiCount, y=num_counts)) +
  geom_point() +
  scale_y_log10() +
  labs(x="AOI Nuclei Count", y="Total Counts",
       title="AOI Nuclei Count vs Total Counts") +
  theme_minimal()
p
ggsave(file.path(plot_dir, "geomx_scatter_nuclei_vs_counts.pdf"), p)

# figure: counts versus background levels
p <- ggplot(ds$samples, aes(x=num_counts, y=snr_q3, color=keep)) +
  geom_point(alpha=0.5) +
  scale_x_log10() +
  scale_y_log10() +
  scale_color_manual(values = pals::cols25()) +
  theme_minimal() +
  labs(x="total counts", y="Q3 (genes) vs Q3 (noise)",
       title="Signal versus noise (Q3)") +
  facet_wrap(~ slide)
p
ggsave(file.path(plot_dir, "geomx_scatter_counts_vs_snrq3.pdf"), p)

```



## bg correction testing

```{r bg correction testing}

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:10]
s <- "s06_r003_fullroi"
xs <- unlist(x[,s])

bw.adjust <- 5
bg.quant <- 0.5

reskdeppv <- bgcorrect_kdeppv(xs, bg, bw.adjust=bw.adjust, ppv.max=0.9)$y
resnorm <- pmax(1, bgcorrect_norm(xs, bg))
resbgsub <- pmax(1, xs - geomean(xs[bg]))
resqq <- bgcorrect_qq(xs, bg, bw.adjust=bw.adjust, bg.quant=bg.quant)$y

summary(reskdeppv)
summary(resnorm)
summary(resbgsub)
summary(resqq)


tbl <- bind_rows(bind_cols(value = xs, bgcorrect="before", bg=bg),
                 bind_cols(value = resnorm, bgcorrect="norm", bg=bg),
                 bind_cols(value = resbgsub, bgcorrect="bgsub", bg=bg),
                 bind_cols(value = reskdeppv, bgcorrect="kdeppv", bg=bg),
                 bind_cols(value = resqq, bgcorrect="qq", bg=bg))
ggplot(tbl, aes(x=value, y=factor(bgcorrect), fill=factor(bg))) +
  stat_density_ridges(alpha=0.5) +
  scale_fill_manual(values = pals::cols25()) + 
  scale_x_log10()

tbl <- bind_cols(xs=xs, ynorm=resnorm, yppv=reskdeppv, yqq=resqq, bg=bg)
ggplot(tbl) + 
  geom_point(data=filter(tbl, bg), aes(xs, ynorm), size=3, alpha=0.5, color="blue") +
  geom_line(data=filter(tbl, !bg), aes(xs, ynorm), color="blue") +
  geom_point(data=filter(tbl, bg), aes(xs, yppv), size=3, alpha=0.5, color="red") +
  geom_line(data=filter(tbl, !bg), aes(xs, yppv), color="red") +
  geom_point(data=filter(tbl, bg), aes(xs, yqq), size=3, alpha=0.5, color="green") +
  geom_line(data=filter(tbl, !bg), aes(xs, yqq), color="green") +
#  geom_hline(yintercept = mean(tbl$y1[bg]), color="red", linetype="dashed") +
#  geom_vline(xintercept = mean(tbl$x1[bg]), color="red", linetype="dashed") + 
  scale_x_log10() + 
  scale_y_log10()

```


## quantile-quantile bg correction
```{r qqbgcorrect}

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:50]
s <- "s03_r051_fullroi"
x <- unlist(x[,s])

log2x <- log2(x)
n <- 2^13
bw <- "nrd"
bw.adjust <- 5
bg.quantile <- 0.5

bw <- bw.nrd(log2x) * bw.adjust

d <- density(log2x[!bg], bw=bw, n=n)
dcdf <- cumsum(d$y) / sum(d$y)

dbg <- density(log2x[bg], bw=bw, n=n)
dbgcdf <- cumsum(dbg$y) / sum(dbg$y)

q <- approx(d$x, dcdf, xout=log2x, ties="ordered")$y
q <- pmax(bg.quantile, q)
log2noise <- approx(dbgcdf, dbg$x, xout=q, ties="ordered")$y
noise <- 2^log2noise

# ensure noise is not greater than (x - 1)
noise <- pmin(noise, x - 1)
y <- x - noise
y <- y - (min(y) - 1)
#y <- pmax(1, x - noise)

# ensure isotonic behavior
ir <- isoreg(x, y)
yf <- ir$yf[order(ir$ord)]

res <- list(
  y = y,
  yf = yf,
  noise = noise,
  dx = d$x,
  dy = d$y,
  dcdf = dcdf,
  dbgx = dbg$x,
  dbgy = dbg$y,
  dbgcdf = dbgcdf,
  bw.adjust = bw.adjust
)

tbl <- bind_cols(bg=bg, 
                 x=log2(x), 
                 noise=log2(res$noise), 
                 y=log2(res$y),
                 yf=log2(res$yf))

ggplot(tbl) +
  geom_line(aes(x, x), color="green") +
  geom_line(aes(x, noise)) +
  geom_line(aes(x, y), color="red", alpha=0.5) +
  geom_line(aes(x, yf), color="blue", alpha=0.5) +
  #geom_point(aes(x, yf, color=bg), alpha=0.5) +
  geom_vline(xintercept=log2(median(x[bg])), color="red", linetype="dashed", alpha=0.5)


res <- bgcorrect_qq(x, bg, bw.adjust = 3, bg.quant=0.5)
tbl <- bind_cols(x=x, bg=bg, noise=res$noise, y=res$y, yf=res$yf)

ggplot(tbl) +
  geom_line(aes(x, x), color="green") +
  geom_line(aes(x, noise)) +
  geom_line(aes(x, y), color="red", alpha=0.5) +
  geom_line(aes(x, yf), color="blue", alpha=0.5) +
  geom_point(aes(x, yf, color=bg), alpha=0.5) +
  scale_x_log10() + 
  scale_y_log10()


```



## BG correction version 3

```{r bgcorrect kdefdr3}

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:50]
s <- "s02_r027_fullroi"
x <- unlist(x[,s])

# parameters
bg.quant <- 0.5
fdr.min <- 0.05
ppv.max <- 0.95
bw.adjust <- 1
eps <- 1e-10
n <- 2^13

x <- log2(x)
xmin <- min(x)
xmax <- max(x)

bw <- bw.nrd(x) * bw.adjust

#bg.cutoff <- quantile(x[bg], fdr.min) - quantile(x[bg], 0)
bg.shift <- quantile(x[bg], fdr.min) - quantile(x[bg], 0)

d <- density(x[!bg], bw=bw, from=xmin, to=xmax, n=n)
dcdf <- cumsum(d$y) / sum(d$y)

dbg <- density(x[bg], bw=bw, from=xmin, to=xmax, n=n)
dbgcdf <- cumsum(dbg$y) / sum(dbg$y)

dbg2 <- density(x[bg] + bg.shift, bw=bw, from=xmin, to=xmax, n=n)
dbgcdf2 <- cumsum(dbg2$y) / sum(dbg2$y)

#dnpv <- dbgcdf / (dcdf + dbgcdf)
#dfor <- dcdf / (dcdf + dbgcdf)
#dppv <- (1 - dcdf + eps) / (1 - dcdf + 1 - dbgcdf + eps)

dfdr <- (1 - dbgcdf) / (1 - dbgcdf + 1 - dcdf + eps)
dfdr2 <- (1 - dbgcdf2) / (1 - dbgcdf2 + 1 - dcdf + eps)


tbl <- bind_cols(dx = d$x,
                 dcdf = dcdf,
                 dbgcdf = dbgcdf,
                 dbgcdf2 = dbgcdf2,
                 dppv = dppv, 
                 dnpv = dnpv,
                 dfor = dfor,
                 dfdr = dfdr,
                 dfdr2 = dfdr2)

ggplot(tbl) +
  geom_line(aes(dx, dcdf)) +
  geom_line(aes(dx, dbgcdf), color="red") +
  geom_line(aes(dx, dbgcdf2), color="red", linetype="dashed") +
#  geom_line(aes(dx, dppv), color="blue", alpha=0.8) +
  geom_line(aes(dx, dfdr), color="magenta", alpha=0.8) +
  geom_line(aes(dx, dfdr2), color="magenta", alpha=0.8, linetype="dashed") +
  geom_vline(xintercept=median(x[bg]), color="red", linetype="dashed", alpha=0.5)



# dppv <- dppv - min(dppv)
# dppv <- ppv.max * dppv / max(dppv)
# summary(dppv)
# # ensure isotonic behavior
# dppv.ir <- isoreg(d$x, dppv)$yf

#f <- splinefun(d$x, dppv.ir, method="monoH.FC", ties="ordered")
#y <- x * f(x)

#ppv <- approx(d$x, dppv.ir, xout=x, ties="ordered")$y
#y <- x * ppv

# ensure isotonic behavior
ppv <- approx(d$x, dppv, xout=x, ties="ordered")$y
y <- x * ppv
ir <- isoreg(x, y)
yf <- ir$yf[order(ir$ord)]

tbl <- bind_cols(x = x, 
                 y = y, 
                 yf = yf)
ggplot(tbl) +
  geom_line(aes(x, x), color="black", alpha=0.5) +
  geom_line(aes(x, y), color="red", alpha=0.5) +
  geom_line(aes(x, yf), color="blue", alpha=0.5)



res <- bgcorrect_kdeppv(x, bg, bw.adjust, ppv.max)

tbl <- bind_cols(dx = res$dx,
                 dcdf = res$dcdf,
                 dbgcdf = res$dbgcdf,
                 dppv = res$dppv)
ggplot(tbl) +
  geom_line(aes(dx, dcdf)) +
  geom_line(aes(dx, dbgcdf), color="red") +
  geom_line(aes(dx, dppv), color="blue", alpha=0.8) +
  geom_vline(xintercept=median(log2(x)[bg]), color="red", linetype="dashed", alpha=0.5)

tbl <- bind_cols(x = x, 
                 y = res$y)
ggplot(tbl) +
  geom_line(aes(x, x), color="black", alpha=0.5) +
  geom_line(aes(x, y), color="blue", alpha=0.5) +
  scale_x_log10() +
  scale_y_log10()


```


## Explore bg distribution using fdr

```{r bgcorrect fdr exploration}

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:50]
s <- "s02_r013_fullroi"
xs <- unlist(x[,s])

res <- cluster_noise(log2(xs), bg)
tbl <- bind_cols(x=res$x,
                 bg=res$bg_dist,
                 bg2=res$bg_dist2,
                 hi=res$hi_dist,
                 hi2=res$hi_dist2,
                 tot=res$bg_dist + res$hi_dist)

ggplot(tbl) +
  geom_point(aes(x,bg), color="red", alpha=0.5) +
  geom_point(aes(x,hi), color="blue", alpha=0.5) +
  geom_point(aes(x,tot)) +
  geom_vline(xintercept=res$bg_center, linetype="dashed", color="red") +
  geom_vline(xintercept=res$hi_center, linetype="dashed", color="blue") +
  geom_vline(xintercept=res$cutoff, linetype="dashed")

table(res$noise)
res$hi_center
res$bg_center
res$fpr
res$cutoff

noise <- bg | res$noise
x <- log2(xs)
xmin <- min(x)
xmax <- max(x)
n <- 10000
eps <- 1e-10
bw.adjust=5
fdr.min <- 0.0

bw <- bw.nrd(x) * bw.adjust

d <- density(x[!noise], bw=bw, from=xmin, to=xmax, n=n)
dcdf <- cumsum(d$y) / sum(d$y)

dbg <- density(x[noise], bw=bw, from=xmin, to=xmax, n=n)
dbgcdf <- cumsum(dbg$y) / sum(dbg$y)
dbgcdf <- pmax(dbgcdf, dcdf)

dfdr <- (1-dbgcdf) / (1-dcdf+eps)
dfdr <- pmin(1, dfdr + fdr.min)
scaled_fdr <- xmin + (xmax - xmin) * cumsum(dfdr) / n
scaled_fdr <- pmin(d$x, scaled_fdr)
xnoise <- approx(d$x, scaled_fdr, xout=x)$y
xnoise <- pmin(xnoise, x)
y <- 2^x - 2^xnoise + 1


tbl <- bind_cols(dx = d$x,
                 dy = d$y,
                 dbg = dbg$y,
                 dbgcdf = dbgcdf,
                 dfdr = dfdr,
                 scaled_fdr = scaled_fdr)

ggplot(tbl) +
  geom_line(aes(dx, dy)) +
  geom_line(aes(dx, dbg), color="red")

ggplot(tbl) +
  geom_line(aes(dx, dfdr), alpha=0.5, color="blue") +
  geom_line(aes(dx, dcdf)) +
  geom_line(aes(dx, dbgcdf), color="red")

ggplot(tbl) +
  geom_line(aes(dx, scaled_fdr))

tbl <- bind_cols(x=xs, y=y, xnoise=2^xnoise, bg=bg, noise=noise)
ggplot(tbl) + 
  geom_point(data=filter(tbl, noise), aes(x, y), size=3, alpha=0.5, color="red") +
  geom_point(data=filter(tbl, !noise), aes(x, y), size=1, alpha=0.3) +
  geom_line(data=filter(tbl, !noise), aes(x, y), alpha=0.5) +
  geom_line(aes(x, xnoise), color="blue") +
  geom_hline(yintercept = mean(tbl$y[bg]), color="red", linetype="dashed") +
  geom_vline(xintercept = mean(tbl$x[bg]), color="red", linetype="dashed") + 
  scale_x_log10() +
  scale_y_log10()


approx(d$x, dbg$y, xout=mean(x))
approx(d$x, d$y, xout=mean(x))
approx(d$x, dfdr, xout=mean(x))



```

## explore clustering with kmeans / sum of squares

```{r clustering kmeans}




cluster_noise <- function(x, bg, scale="log2") {
  
  if (scale == "log2") {
    x <- log2(x)
  } else if (scale == "rank") {
    x <- rank(x, ties.method="first")
  }

  xgene <- sort(x[!bg])
  xgene.cumsum <- cumsum(xgene)
  xgene.sum <- xgene.cumsum[length(xgene)]
  
  bg_center <- mean(x[bg])
  bg_dists <- cumsum(abs(xgene - bg_center))
  #bg_dists <- cumsum((xgene - bg_center)^2)

  hi_centers <- rep(0, length(xgene))
  hi_dists <- rep(0, length(xgene))
  for (i in 1:(length(xgene)-1)) {
    hi_centers[i] <- (xgene.sum - xgene.cumsum[i])/(length(xgene) - i)
    hi_dists[i] <- sum(abs(xgene[(i+1):length(xgene)] - hi_centers[i]))
    #hi_dists[i] <- sum((xgene[(i+1):length(xgene)] - hi_centers[i])^2)
  }
  tot_dists <- bg_dists + hi_dists
  cutoff_index <- which.min(tot_dists)
  cutoff <- xgene[cutoff_index]
  hi_center <- hi_centers[cutoff_index]
  noise <- (x <= cutoff)
  fpr <- sum(x[bg] > cutoff)/length(x[bg])
  
  return(list(x=xgene,
              bg_center=bg_center,
              hi_center=hi_center,
              bg_dist=bg_dists, 
              hi_dist=hi_dists, 
              noise=noise,
              fpr=fpr,
              cutoff=cutoff))
}

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:50]
s <- "s04_r058_fullroi"
xs <- unlist(x[,s])

a <- cluster_noise(xs, bg)

tbl <- bind_cols(x=a$x,
                 bg=a$bg_dist,
                 hi=a$hi_dist,
                 tot=a$bg_dist + a$hi_dist)

ggplot(tbl) +
  geom_point(aes(x,bg), color="red", alpha=0.5) +
  geom_point(aes(x,hi), color="blue", alpha=0.5) +
  geom_point(aes(x,tot)) + 
  geom_vline(xintercept=a$bg_center, linetype="dashed", color="red") +
  geom_vline(xintercept=a$hi_center, linetype="dashed", color="blue") +
  geom_vline(xintercept=a$cutoff, linetype="dashed")

clustering <- ifelse(bg, "bg", ifelse(a$noise, "no", "yes"))
tbl <- bind_cols(x=xs, clustering=clustering)

ggplot(tbl, aes(x=x, y=factor(clustering), fill=factor(clustering))) +
  stat_density_ridges(alpha=0.5) +
  scale_x_log10()



```


## Explore clustering with silhouette scores

```{r clustering silhouette}

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:50]
s <- "s04_r062_fullroi"
xs <- unlist(x[,s])
xs <- log2(xs)

xbg <- xs[bg]
xbgrle <- rle(sort(xbg))
xbg.length <- length(xbgrle$values)

x <- xs[!bg]
xrle <- rle(sort(x))
x.length <- length(xrle$values)

xvals <- c(xbgrle$values, xrle$values)
xlens <- c(xbgrle$lengths, xrle$lengths)

dmatrix <- matrix(0, length(xvals), length(xvals))
for (i in 1:length(xvals)) {
  for (j in 1:length(xvals)) {
    dmatrix[i, j] <- xvals[i] - xvals[j]
#    dmatrix[i, j] <- abs(xvals[i] - xvals[j])
  }
}
dmatrix <- sweep(dmatrix, 2, xlens, FUN="*")
#dmatrix <- as.matrix(dist(xvals))

minclustsize <- 10
irange <- (xbg.length + minclustsize):(length(xvals) - minclustsize)





i <- irange[1000]
clustering <- c(rep("bg", xbg.length), rep("lo", i - xbg.length), rep("hi", length(xvals) - i))

clust_bg_n <- sum(xlens[1:xbg.length])
clust_lo_n <- sum(xlens[(xbg.length+1):i])
clust_hi_n <- sum(xlens[(i+1):length(xlens)])
clust_bg_dsum <- apply(dmatrix[, 1:xbg.length], 1, sum)
clust_lo_dsum <- apply(dmatrix[, (xbg.length+1):i], 1, sum)
clust_hi_dsum <- apply(dmatrix[, (i+1):ncol(dmatrix)], 1, sum)

dlo <- clust_lo_dsum[(xbg.length+1):i] / (clust_lo_n - xlens[(xbg.length+1):i])
dbg <- clust_bg_dsum[(xbg.length+1):i] / clust_bg_n
dhi <- clust_hi_dsum[(xbg.length+1):i] / clust_hi_n


tbl <- bind_cols(x = xvals[(xbg.length+1):i],
                 dbg = dbg,
                 dlo = dlo,
                 dhi = dhi)

ggplot(tbl) +
  geom_point(aes(x, dbg), color="red") +
  geom_point(aes(x, dlo), color="blue") +
  geom_point(aes(x, dhi), color="green")

irange[1000]
plot(dmatrix[1098,])
clust_bg_dsum[1098]
clust_lo_dsum[1098]
clust_hi_dsum[1098]
plot(clust_lo_dsum)



clust_bg_n <- sum(xlens[1:xbg.length])
clust_bg_dsum <- apply(dmatrix[, 1:xbg.length], 1, sum)

minclustsize <- 10
irange <- (xbg.length + minclustsize):(length(xvals) - minclustsize)
a <- NULL
b <- NULL
c <- NULL
d <- NULL
for (i in irange) {
  clust_lo_n <- sum(xlens[(xbg.length+1):i])
  clust_hi_n <- sum(xlens[(i+1):length(xlens)])
  clust_lo_dsum <- apply(dmatrix[, (xbg.length+1):i], 1, sum)
  clust_hi_dsum <- apply(dmatrix[, (i+1):ncol(dmatrix)], 1, sum)
  
  dlo <- clust_lo_dsum[(xbg.length+1):i] / (clust_lo_n - xlens[(xbg.length+1):i])
  dbg <- clust_bg_dsum[(xbg.length+1):i] / clust_bg_n
  dhi <- clust_hi_dsum[(xbg.length+1):i] / clust_hi_n
  
  a[i] <- mean(dbg)
  b[i] <- mean(dlo)
  c[i] <- mean(dhi)
  d[i] <- mean(dhi - dlo - dbg)
}

tbl <- bind_cols(x=xvals[irange],
                 a=a[irange],
                 b=b[irange],
                 c=c[irange],
                 d=d[irange])
ggplot(tbl) +
  geom_point(aes(x,a), color="red") +
  geom_point(aes(x,b), color="blue") +
  geom_point(aes(x,c), color="green") +
  geom_point(aes(x,d))


```



## Explore ks distance to partition gene probes into signal and noise

```{r bgcorrect ks dist}

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:50]
s <- "s01_r056_fullroi"
xs <- unlist(x[,s])

minclustsize <- 20

dist(c(1,2,3,4,5))

xs <- log2(xs)
x <- sort(xs[!bg])
xall <- unique(sort(xs))

xrle <- rle(x)
xrle.n <- length(xrle$values)
xcumsum <- cumsum(xrle$lengths)

xbg <- sort(xs[bg])
xbgrle <- rle(xbg)
xbgcdf <- cumsum(xbgrle$lengths)/length(xbg)

bgcdf <- approx(xbgrle$values, xbgcdf, xout=xall, yleft=0, yright=1)$y

dlo <- rep(0, length(xall))
dhi <- rep(0, length(xall))
for (i in minclustsize:(length(xall)-minclustsize)) {
  locdf <- xcumsum[1:(i-1)] / xcumsum[(i-1)]
  hicdf <- xcumsum[i:xrle.n] / xcumsum[xrle.n]
  locdf <- approx(xrle$values[1:(i-1)], locdf, xout=xall, yleft=0, yright=1)$y
  hicdf <- approx(xrle$values[i:xrle.n], hicdf, xout=xall, yleft=0, yright=1)$y
  dlo[i] <- max(bgcdf - locdf)
  dhi[i] <- max(locdf - hicdf)
}


tbl <- bind_cols(x=xall, dlo=dlo, dhi=dhi)
ggplot(tbl) + 
  geom_point(aes(x, dlo)) +
  geom_line(aes(x, dlo)) +
  geom_point(aes(x, dhi), color="red") +
  geom_line(aes(x, dhi), color="red") +
  scale_x_log10()


i <- 500
locdf <- xcumsum[1:(i-1)] / xcumsum[(i-1)]
hicdf <- (xcumsum[i:xrle.n] - xcumsum[(i-1)]) / (xcumsum[xrle.n] - xcumsum[(i-1)])
locdf <- approx(xrle$values[1:(i-1)], locdf, xout=xall, yleft=0, yright=1)$y
hicdf <- approx(xrle$values[i:xrle.n], hicdf, xout=xall, yleft=0, yright=1)$y

tbl <- bind_cols(x=xall, bgcdf=bgcdf, locdf=locdf, hicdf=hicdf)
ggplot(tbl) +
  geom_point(aes(x, bgcdf)) +
  geom_line(aes(x, bgcdf)) +
  geom_point(aes(x, locdf), color="red") +
  geom_line(aes(x, locdf), color="red") +
  geom_point(aes(x, hicdf), color="blue") +
  geom_line(aes(x, hicdf), color="blue") +
  scale_x_log10()

ggplot(tbl) +
  geom_line(aes(x, bgcdf - locdf), color="red") +
  geom_line(aes(x, locdf - hicdf), color="blue") +
  geom_line(aes(x, (bgcdf - locdf) + (locdf - hicdf))) +
  scale_x_log10()




x <- log2(x1)

rle(xsort)
min(xsort)
?rle

# choose starting index
#max(which(xsort < quantile(xbg, 0.5)))
istart <- minclustsize
iend <- length(xsort) - minclustsize
dmin <- NULL
dmax <- NULL
j <- 1
for (i in istart:iend) {
  xlo <- xsort[1:(i-1)]
  xhi <- xsort[i:length(xsort)]
  
  dmin[j] <- suppressWarnings(ks.test(xbg, xlo, alternative="greater")$statistic)
  dmax[j] <- suppressWarnings(ks.test(c(xbg, xlo), xhi, alternative="greater")$statistic)
  j <- j + 1
  
  if (j %% 100 == 0) {
    print(j)
  }
}


ks.test(c(2000, 234098, 23490, 213), c(1,2,3,4,5,6,7,8,9,10))


tbl <- bind_cols(dmin=dmin, dmax=dmax)
ggplot(tbl) + 
  geom_line(aes(x=1:length(dmin), y=dmin)) +
  geom_line(aes(x=1:length(dmax), y=dmax), color="red") +
  geom_line(aes(x=1:length(dmax), y=dmax - dmin), color="blue")


xmin <- min(x)
xmax <- max(x)
n <- 10000
bw.adjust <- 3
bw <- bw.nrd(x) * bw.adjust

d <- density(x[!bg], bw=bw, from=xmin, to=xmax, n=n)
dbg <- density(x[bg], bw=bw, from=xmin, to=xmax, n=n)

dcdf <- cumsum(d$y) / (sum(d$y))
dbgcdf <- cumsum(dbg$y) / (sum(dbg$y))





dbgcdf <- pmax(dbgcdf, dcdf)

dfdr <- (1-dbgcdf) / (1-dcdf)
dfdr[which(is.nan(dfdr))] <- min(dfdr[which(!is.nan(dfdr))])
dfdr <- pmin(1, dfdr + fdr.min)

scaled_fdr <- xmin + (xmax - xmin) * cumsum(dfdr) / n
scaled_fdr <- pmin(d$x, scaled_fdr)
noise <- approx(d$x, scaled_fdr, xout=x)$y
noise <- pmin(noise, x)


```


## Explore bg distribution using LR / filter

```{r bgcorrect lr filter}
library(mixtools)
library(fitdistrplus)
library(stats4)
library(MASS)
# for other necessary test or graphical tools
library(survival)
library(actuar)
library(distrMod)

bg <- ds$meta$bg
x <- ds$counts

sort(ds$samples$bg_auc)[1:20]
sort(ds$samples$bg_auc, decreasing=TRUE)[1:50]
s <- "s05_r049_fullroi"
x1 <- unlist(x[,s])

x <- log2(x1)
npEM(x, 2, bg)

plotdist(x[bg], histo=TRUE, demp=TRUE)
descdist(x, discrete=FALSE, boot=1000)

f <- fitdist(x[bg], "logis")
f <- fitdist(x, "lnorm")
plot(f, breaks=100)
summary(f)

```



```{r test bg correction}

x <- st_geomx_bgcorrect(ds, method="qq")

bg <- ds$meta$bg
#s <- "s03_r030_fullroi"
s <- "s04_r058_fullroi"
x1 <- unlist(ds$counts[, s])
y1 <- unlist(x[, s])

range(x1)
range(y1)
range(x1[bg])
tbl <- bind_rows(bind_cols(value = x1, bgcorrect="before", bg=bg),
                 bind_cols(value = y1, bgcorrect="after", bg=bg),
                 bind_cols(value = x1-y1, bgcorrect="noise", bg=bg))

ggplot(tbl, aes(x=value, y=factor(bgcorrect), fill=factor(bg))) +
  stat_density_ridges(alpha=0.5) +
  scale_x_log10()



# bg <- ds$meta$bg
x <- log2(ds$counts)
#x1 <- unlist(x[, "s03_r030_fullroi"])
x1 <- unlist(x[, "s06_r044_fullroi"])
#x1 <- unlist(x[, "s04_r058_fullroi"])

bgvar <- sd(x1[bg])^2
bgmean <- mean(x1[bg])
x1var <- sd(x1)^2
x1mean <- mean(x1)

a <- bgvar / x1var
m <- 1 - a
c <- a * x1mean - bgmean

y1 <- m*x1 + c
y1 <- pmax(y1, 0)
y1 <- 2^y1


tbl <- bind_rows(bind_cols(value = x1, bgcorrect="before", bg=bg),
                 bind_cols(value = y1, bgcorrect="after", bg=bg),
                 bind_cols(value = x1-y1, bgcorrect="noise", bg=bg))

ggplot(tbl, aes(x=value, y=factor(bgcorrect), fill=factor(bg))) +
  stat_density_ridges(alpha=0.5) +
  scale_x_log10()

tbl <- bind_cols(x1= x1, y1 = y1, bg= bg)
ggplot(tbl) +
  geom_point(data=filter(tbl, bg), aes(x1, y1), color="red") +
  geom_line(data=filter(tbl, !bg), aes(x1, y1), color="black") +
#  geom_line(aes(x1, x1-y1), color="red") +
  geom_hline(yintercept = mean(y1[bg]), color="red", linetype="dashed") +
  geom_vline(xintercept = mean(x1[bg]), color="red", linetype="dashed") +
  scale_x_log10() +
  scale_y_log10()

```

