---
title: "soa"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{soa}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Setup

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(tidyverse)
library(readxl)
library(ggrepel)
library(pheatmap)

# bioconductor packages
library(factoextra)

```

## Vignette-specific functions

```{r vignette functions, include=FALSE}

add_study_field <- function(ds, study) {
  s <- ds$samples
  s$study <- study
  s <- s %>% mutate(patient = sprintf("%s_%s", study, patient),
                    slide = sprintf("%s_%s", study, slide),
                    roi = sprintf("%s_%s", study, roi),
                    aoi = sprintf("%s_%s", study, aoi))
  colnames(ds$counts) <- s$aoi
  return(list(samples = s, meta = ds$meta, counts = ds$counts))
}

merge_ds <- function(a, b) {
  # merge sample tables
  sample_cols <- intersect(colnames(a$samples), colnames(b$samples))
  s <- bind_rows(select(a$samples, all_of(sample_cols)),
                 select(b$samples, all_of(sample_cols)))
  # merge count data
  a_counts <- bind_cols(select(a$meta, probe, gene, bg), a$counts)
  b_counts <- bind_cols(select(b$meta, probe, gene, bg), b$counts)
  counts <- inner_join(a_counts, b_counts, by=c("probe", "gene", "bg"),
                       relationship="one-to-one")
  # break into metadata and count data
  meta <- select(counts, -all_of(s$aoi))
  counts <- select(counts, all_of(s$aoi))
  
  # make new dataset object
  ds <- stgeomx::init(samples=s, meta=meta, counts=counts, x=counts)
  return(ds)
}

save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
  stopifnot(!missing(x))
  stopifnot(!missing(filename))
  pdf(filename, width=width, height=height)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}

```

## Input files and parameter settings

```{r input files, include=FALSE}

# input directories
working_dir <- "/Users/mkiyer/Dropbox (University of Michigan)/MED-mctp-iyerlab/projects/stgeomx_methods"

# geomx data file location
geomx_dir <- file.path(working_dir, "geomx")

#
# spatial organ atlas pancreas dataset
#
# TODO: I have set up annotations for the pancreas data but have not yet
# annotated the other datasets
soa_panc_geomx_xlsx <- file.path(geomx_dir, "soa_panc_data.xlsx")
soa_panc_geomx_annot_xlsx <- file.path(geomx_dir, "soa_panc_annot.xlsx")

#
# output directory settings
#
results_dir <- file.path(working_dir, "results")
plot_dir <- file.path(results_dir, "plots")
# create output directories
for (d in c(results_dir, plot_dir)) {
  if (!dir.exists(d)) {
    dir.create(d)
  }
}

#
# filtering parameter settings
#
# gene probes must be greater than the Nth quantile of the noise/background
# probes to be considered 'detectable'
geomx_negprobe_lod_quantile = 0.9
# minimum number of total counts for each area-of-interest (AOI)
geomx_min_counts = 50000
# signal-to-noise area under the curve (snAUC) threshold for each AOI
geomx_min_auc = 0.60
# AOI must have at least this fraction of all genes detectable
geomx_aoi_min_frac_expr = 0.2
# a gene must be 'detectable' in at least this fraction of the AOIs to be kept
geomx_gene_min_frac_expr = 0.15

#
# background correction / normalization parameter settings
#
# background (noise) correction methods:
# bgsub: subtract a constant noise value from every gene
# qq: models and subtracts background noise relative to gene probe count
# none: no background correction
bgcorrect_method = "qq"
# kernel density estimation is used to model a smooth noise distribution
# from the small set of background noise probes. modifying the bandwidth 
# parameter will affect how "smooth" the background distribution model is
bgcorrect_bw_adjust = 2
# ensure that gene probes below this quantile in the background noise 
# distribution are zero. A value of 0.5 means that the gene is 
# indistinguishable from background (50% likelihood of being noise)
bgcorrect_bg_quant = 0.5
#
# normalization method options:
# qn: quantile normalization (recommended)
# rle: deseq2 normalization
# cpm: counts per million
# q3: upper quartile normalization
# tmm: edgeR TMM normalization
# none: no normalization
norm_method = "qn"

```


# stgeomx

## Read and process geomx data

```{r soa panc geomx data, include=FALSE}

# read data
ds <- stgeomx::read_xlsx(soa_panc_geomx_xlsx)
# read and join sample annotation
annot <- read_excel(soa_panc_geomx_annot_xlsx)
ds$samples <- ds$samples %>% 
  inner_join(annot, by="SegmentDisplayName")

# process dataset
ds <- stgeomx::preprocess(ds, geomx_negprobe_lod_quantile)
# merge probes when there is >1 probe per gene
ds <- stgeomx::merge_probes(ds)

# set filtering thresholds
ds <- stgeomx::set_thresholds(ds,
                              min_counts = geomx_min_counts,
                              min_auc = geomx_min_auc,
                              aoi_min_frac_expr = geomx_aoi_min_frac_expr,
                              gene_min_frac_expr = geomx_gene_min_frac_expr)

```

## QC: AOI filtering

```{r qc filter aoi}

p <- stgeomx::plot_aoi_filter(ds, 
                              min_counts=geomx_min_counts,
                              min_auc=geomx_min_auc,
                              min_frac_expr=geomx_aoi_min_frac_expr)
p
w <- 9
h <- 4
f <- file.path(plot_dir, "qc_aoi_filtering")
ggsave(paste0(f, ".png"), p, width=w, height=h)
ggsave(paste0(f, ".pdf"), p, width=w, height=h)

```

## QC: Gene Filtering

```{r gene filtering}
p <- stgeomx::plot_gene_filter(ds, geomx_gene_min_frac_expr)
p
w <- 7
h <- 7
f <- file.path(plot_dir, "qc_gene_filtering")
ggsave(paste0(f, ".png"), p, width=w, height=h)
ggsave(paste0(f, ".pdf"), p, width=w, height=h)

```

## BG correction and normalization

```{r background correction}

# background correction must use original unfiltered matrix
fds <- stgeomx::bgcorrect(ds, method=bgcorrect_method, 
                          bw.adjust=bgcorrect_bw_adjust, 
                          bg.quant=bgcorrect_bg_quant)
# normalize
fds <- stgeomx::normalize(fds, norm_method)

# plot expression distribution
p <- stgeomx::plot_expr_dist(fds)
p
w <- 8
h <- 8
f <- file.path(plot_dir, "qc_expr_dist")
ggsave(paste0(f, ".png"), p, width=w, height=h)
ggsave(paste0(f, ".pdf"), p, width=w, height=h)

# plot background correction (before and after)
p <- stgeomx::plot_bgcorrect2(fds)
p
w <- 8
h <- 8
f <- file.path(plot_dir, "qc_bgcorrect")
ggsave(paste0(f, ".png"), p, width=w, height=h)
ggsave(paste0(f, ".pdf"), p, width=w, height=h)

# background correction must use original unfiltered matrix
fds <- stgeomx::bgcorrect(ds, method=bgcorrect_method,
                          bw.adjust=bgcorrect_bw_adjust,
                          bg.quant=bgcorrect_bg_quant)
# apply filters before normalizing
fds <- stgeomx::apply_filters(fds)
# normalize
fds <- stgeomx::normalize(fds, norm_method)

# filtering stats
nrow(ds$samples)
nrow(fds$samples)
table(ds$meta$keep)

# final normalized gene expression matrix
log2_norm_cpm <- log2(fds$x + 1)

```

# Downstream data analysis 

## Highly variable genes

```{r highly variable genes, include=FALSE}

most_var_genes <- function(x, ntop=500, span=0.50) {
  tbl <- bind_cols(
    u = rowMeans(x),
    v = apply(x, 1, function(x) var(x))
  )
  lovar <- loess(v ~ u, data=tbl, span=span)
  tbl$lovar <- predict(lovar)
  tbl$vadj <- abs(tbl$v / tbl$lovar)
  keep <- order(tbl$vadj, decreasing=TRUE)[seq_len(min(ntop, nrow(tbl)))]
  return(x[keep,])
}

y <- log2_norm_cpm
ntop <- 1000
nlabel <- 100
myspan <- 0.5

# plot most variable genes
tbl <- bind_cols(
  g = rownames(y),
  u = rowMeans(y),
  v = apply(y, 1, function(x) var(x))
)
lovar <- loess(v ~ u, data=tbl, span=myspan)
tbl$lovar <- predict(lovar)
tbl$vadj <- abs(tbl$v / tbl$lovar)
tbl <- tbl %>% 
  mutate(rank = min_rank(-vadj)) %>%
  arrange(rank)
label_data <- filter(tbl, rank <= nlabel)

p <- ggplot(tbl) +
  geom_point(aes(u, v), alpha=0.5, color="#ffaaaa") +
  geom_line(aes(u, lovar), color="blue") +
  geom_text_repel(data=label_data, aes(u, v, label=g), color="black", size=3, max.overlaps=Inf) +
  theme_minimal()
f <- file.path(plot_dir, paste0("maplot"))
ggsave(paste0(f, ".pdf"), plot=p, width=10, height=10)
ggsave(paste0(f, ".png"), plot=p, width=10, height=10)

# select most variable genes
y <- most_var_genes(log2_norm_cpm, ntop=ntop, span=myspan)

s <- fds$samples %>% mutate(
  noise_quantile = ntile(desc(bg_auc), 8)
)

annot_col <- column_to_rownames(s, "aoi") %>% 
  select(study, patient, path_specimen, path_aoi, noise_quantile) %>%
  as.data.frame()

f <- file.path(plot_dir, "heatmap_cluster_highvar_genes")
w <- 12
h <- 12
p <- pheatmap(y,
              scale="row",
              show_rownames=FALSE,
              show_colnames=FALSE,
              border_color=NA,
              clustering_method = "average",
              clustering_distance_rows = "correlation",
              clustering_distance_cols = "correlation",
              breaks = seq(-3, 3, 0.05),
              color = colorRampPalette(c("purple3", "black", "yellow2"))(120),
              annotation_col = annot_col,
              #annotation_colors = color_scales,
              filename=paste0(f, ".png"), width=w, height=h)
save_pheatmap_pdf(p, filename=paste0(f, ".pdf"), width=w, height=h)


```

## PCA

```{r pca}

# subset most variable genes
ntop <- 250
myspan <- 0.5
s <- fds$samples
y <- most_var_genes(log2_norm_cpm, ntop=ntop, span=myspan)

# plot dimensions
width <- 8
height <- 6

# PCA
res.pca <- prcomp(t(y), center=TRUE, scale.=TRUE)
res.pca_var <- round(100 * res.pca$sdev^2 / sum( res.pca$sdev^2 ), 2)
res.pca_var_txt <- paste(colnames(res.pca$x), " (", paste(as.character(res.pca_var), "%", ")", sep=""), sep="")

# fviz plots
fviz_ntop <- 50

# percent variance of each PC
p <- fviz_eig(res.pca, col.var="blue", addlabels=TRUE)
f <- file.path(plot_dir, paste0("pca_fviz_eig.pdf"))
ggsave(f, p)

# contributions of variables to PC1 and PC2
p <- fviz_contrib(res.pca, choice="var", axes = 1:2, top=fviz_ntop) +
  theme(axis.text.x = element_text(angle=90))
f <- file.path(plot_dir, paste0("pca_fviz_contrib.pdf"))
ggsave(f, p)

# graph of variables contributing to PCA
p <- fviz_pca_var(
  res.pca,
  col.var = "contrib", # Color by the quality of representation
  gradient.cols = c("darkorchid4", "gold", "darkorange"),
  repel=TRUE,
  select.var = list(contrib=fviz_ntop)
)
f <- file.path(plot_dir, paste0("pca_fviz_pca_var.pdf"))
ggsave(f, p, width=7, height=7)


#
# PCA plots
#
x <- bind_cols(s, as_tibble(res.pca$x))

# bg_auc
p <- ggplot(x, aes(x=PC1, y=PC2, color=bg_auc)) +
  geom_point(alpha = 0.8, size=3) +
  scale_color_viridis_c() +
  theme_bw() +
  labs(x=res.pca_var_txt[1], y=res.pca_var_txt[2])
f <- file.path(plot_dir, paste0("pca_bg_auc.pdf"))
ggsave(f, plot=p, device="pdf", width=width, height=height)

# patient
p <- ggplot(x, aes(x=PC1, y=PC2, color=patient, shape=path_specimen)) +
  geom_point(alpha = 0.8, size=3) +
  scale_color_manual(values = pals::cols25()) +
  theme_bw() +
  labs(x=res.pca_var_txt[1], y=res.pca_var_txt[2])
f <- file.path(plot_dir, paste0("pca_patient.pdf"))
ggsave(f, plot=p, device="pdf", width=width, height=height)

# segment
p <- ggplot(x, aes(x=PC1, y=PC2, color=segment, shape=patient)) +
  geom_point(alpha = 0.8, size=3) +
  scale_color_manual(values=pals::cols25()) +
  theme_bw() +
  labs(x=res.pca_var_txt[1], y=res.pca_var_txt[2])
f <- file.path(plot_dir, paste0("pca_segment.pdf"))
ggsave(f, plot=p, device="pdf", width=width, height=height)


#
# plots of PC1, PC2, and PC3
#
# patient
p1 <- ggplot(x, aes(x=PC1, y=PC2, color=segment, shape=patient)) +
  geom_point(alpha = 0.8, size=3) +
  scale_color_manual(values = pals::cols25()) +
  theme_bw() +
  theme(legend.position="none") +
  labs(x=res.pca_var_txt[1], y=res.pca_var_txt[2])
p2 <- ggplot(x, aes(x=PC3, y=PC2, color=segment, shape=patient)) +
  geom_point(alpha = 0.8, size=3) +
  scale_color_manual(values = pals::cols25()) +
  theme_bw() +
  labs(x=res.pca_var_txt[3], y=res.pca_var_txt[2])
p <- p1 + p2
f <- file.path(plot_dir, paste0("pca_segment_patient_12_23.pdf"))
ggsave(f, plot=p, device="pdf", width=7, height=3)


```





